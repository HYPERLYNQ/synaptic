# Synaptic v0.5.0 — Intelligence Layer Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Transform Synaptic from persistent memory to intelligent memory with confidence scoring, cross-project awareness, auto-rules, conversation distillation, predictive injection, agent context sharing, and codebase-aware co-change tracking.

**Architecture:** Three-wave rollout. Wave 1 adds schema changes, scoring, and two new tools. Wave 2 enhances hooks with project filtering, distillation, and correction detection. Wave 3 wires intelligence features into session-start injection.

**Tech Stack:** TypeScript, Node.js 22+ (built-in sqlite), sqlite-vec, Transformers.js (Xenova/all-MiniLM-L6-v2), MCP SDK.

**Design doc:** `docs/plans/2026-02-15-v0.5.0-intelligence-design.md`

---

## Wave 1 — Data Foundation

### Task 1: Schema Migration

**Files:**
- Modify: `src/storage/sqlite.ts` (migrate method, ~line 75-110)

**Step 1: Write the failing test**

Add to `scripts/smoke-test.ts` after the existing tests:

```typescript
// -------------------------------------------------------
// 13. Test v0.5.0 schema migration (project, session_id, agent_id columns)
// -------------------------------------------------------
console.log("\n[13] v0.5.0 schema migration");

const colCheck = (rawDb: DatabaseSync, col: string) => {
  const cols = rawDb.prepare("PRAGMA table_info(entries)").all() as Array<{ name: string }>;
  return cols.some(c => c.name === col);
};

const rawDb3 = new DatabaseSync(DB_PATH);
assert(colCheck(rawDb3, "project"), "entries table has 'project' column");
assert(colCheck(rawDb3, "session_id"), "entries table has 'session_id' column");
assert(colCheck(rawDb3, "agent_id"), "entries table has 'agent_id' column");

// Check file_pairs table exists
const tables = rawDb3.prepare("SELECT name FROM sqlite_master WHERE type='table' AND name='file_pairs'").all();
assert(tables.length === 1, "file_pairs table exists");

// Check indexes
const indexes = rawDb3.prepare("SELECT name FROM sqlite_master WHERE type='index'").all() as Array<{ name: string }>;
assert(indexes.some(i => i.name === "idx_entries_project"), "idx_entries_project index exists");
assert(indexes.some(i => i.name === "idx_entries_session"), "idx_entries_session index exists");
assert(indexes.some(i => i.name === "idx_file_pairs_lookup"), "idx_file_pairs_lookup index exists");
rawDb3.close();
```

**Step 2: Run test to verify it fails**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run smoke-test`
Expected: FAIL — columns and table don't exist yet.

**Step 3: Implement the migration**

In `src/storage/sqlite.ts`, add to the end of the `migrate()` method:

```typescript
// v0.5.0 migration: project, session_id, agent_id columns
const hasProject = columns.some((col) => col.name === "project");
if (!hasProject) {
  this.db.exec("ALTER TABLE entries ADD COLUMN project TEXT DEFAULT NULL");
  this.db.exec("ALTER TABLE entries ADD COLUMN session_id TEXT DEFAULT NULL");
  this.db.exec("ALTER TABLE entries ADD COLUMN agent_id TEXT DEFAULT NULL");
  this.db.exec("CREATE INDEX IF NOT EXISTS idx_entries_project ON entries(project)");
  this.db.exec("CREATE INDEX IF NOT EXISTS idx_entries_session ON entries(session_id)");
}

// v0.5.0: file_pairs table for co-change tracking
this.db.exec(`
  CREATE TABLE IF NOT EXISTS file_pairs (
    project TEXT NOT NULL,
    file_a TEXT NOT NULL,
    file_b TEXT NOT NULL,
    co_change_count INTEGER DEFAULT 1,
    last_seen TEXT NOT NULL,
    PRIMARY KEY (project, file_a, file_b)
  )
`);
this.db.exec("CREATE INDEX IF NOT EXISTS idx_file_pairs_lookup ON file_pairs(project, file_a)");
```

Also update the `insert()` method signature and SQL to include the new columns:

```typescript
insert(entry: ContextEntry & { project?: string; sessionId?: string; agentId?: string }): number {
  const stmt = this.db.prepare(`
    INSERT OR REPLACE INTO entries (id, date, time, type, tags, content, source_file, tier, access_count, last_accessed, pinned, archived, label, project, session_id, agent_id)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `);
  stmt.run(
    entry.id,
    entry.date,
    entry.time,
    entry.type,
    entry.tags.join(", "),
    entry.content,
    entry.sourceFile,
    entry.tier ?? "working",
    entry.accessCount ?? 0,
    entry.lastAccessed ?? null,
    entry.pinned ? 1 : 0,
    entry.archived ? 1 : 0,
    (entry as any).label ?? null,
    entry.project ?? null,
    entry.sessionId ?? null,
    entry.agentId ?? null
  );
  const row = this.db.prepare("SELECT last_insert_rowid() as rowid").get() as Record<string, unknown>;
  return row.rowid as number;
}
```

Update `getByRowids()` and `list()` to include the new columns in SELECT and in the returned objects. Add `project`, `sessionId`, `agentId` fields to the mapped output.

**Step 4: Run test to verify it passes**

Run: `npm run smoke-test`
Expected: PASS

**Step 5: Commit**

```bash
git add src/storage/sqlite.ts scripts/smoke-test.ts
git commit -m "feat: v0.5.0 schema migration — project, session_id, agent_id columns + file_pairs table"
```

---

### Task 2: Project Auto-Detection

**Files:**
- Create: `src/storage/project.ts`
- Modify: `src/server.ts` (~line 1-10, imports + detection on startup)

**Step 1: Write the failing test**

Add to `scripts/smoke-test.ts`:

```typescript
// -------------------------------------------------------
// 14. Test project auto-detection
// -------------------------------------------------------
console.log("\n[14] Project auto-detection");

import { detectProject } from "../src/storage/project.js";

const projectFromGit = detectProject(PROJECT_DIR);
assert(projectFromGit === "claude-context-tool", `detectProject from git repo = "claude-context-tool" (got "${projectFromGit}")`);

const projectFromFolder = detectProject("/tmp/claude/fake-project");
assert(projectFromFolder === "fake-project", `detectProject from folder name = "fake-project" (got "${projectFromFolder}")`);
```

**Step 2: Run test to verify it fails**

Run: `npm run smoke-test`
Expected: FAIL — `project.ts` doesn't exist.

**Step 3: Implement project detection**

Create `src/storage/project.ts`:

```typescript
import { execSync } from "node:child_process";
import { basename } from "node:path";
import { isGitRepo } from "./git.js";

let cachedProject: string | null = null;

export function detectProject(cwd?: string): string | null {
  if (cachedProject !== null) return cachedProject;
  const dir = cwd ?? process.cwd();

  // Try git remote name first
  if (isGitRepo(dir)) {
    try {
      const remote = execSync("git remote get-url origin", {
        cwd: dir,
        encoding: "utf-8",
        timeout: 3000,
      }).trim();
      // Parse repo name from URL: git@github.com:user/repo.git or https://github.com/user/repo.git
      const match = remote.match(/\/([^/]+?)(?:\.git)?$/) ?? remote.match(/:([^/]+?)(?:\.git)?$/);
      if (match) {
        cachedProject = match[1];
        return cachedProject;
      }
    } catch {
      // Fall through to folder name
    }
  }

  // Fall back to folder name
  cachedProject = basename(dir) || null;
  return cachedProject;
}

export function resetProjectCache(): void {
  cachedProject = null;
}
```

In `src/server.ts`, import and detect project at startup. Store it as a module-level variable that tools can access:

```typescript
import { detectProject } from "./storage/project.js";

let _currentProject: string | null = null;

export function getCurrentProject(): string | null {
  return _currentProject;
}

export function createServer(): McpServer {
  ensureDirs();
  _currentProject = detectProject();
  // ... rest of createServer
}
```

**Step 4: Run test to verify it passes**

Run: `npm run smoke-test`
Expected: PASS

**Step 5: Commit**

```bash
git add src/storage/project.ts src/server.ts scripts/smoke-test.ts
git commit -m "feat: project auto-detection from git remote or folder name"
```

---

### Task 3: Session ID Detection + Auto-Tagging on Save

**Files:**
- Create: `src/storage/session.ts`
- Modify: `src/tools/context-save.ts` — add agent_id param, auto-tag project + session_id
- Modify: `src/server.ts` — expose session getter

**Step 1: Write the failing test**

Add to `scripts/smoke-test.ts`:

```typescript
// -------------------------------------------------------
// 15. Test session ID + auto-tagging on save
// -------------------------------------------------------
console.log("\n[15] Session ID + auto-tagging");

import { getSessionId } from "../src/storage/session.js";

const sid = getSessionId();
assert(typeof sid === "string" && sid.length > 0, `getSessionId returns a string (got "${sid}")`);
assert(getSessionId() === sid, `getSessionId returns same value on second call (cached)`);
```

**Step 2: Run test to verify it fails**

Run: `npm run smoke-test`
Expected: FAIL — `session.ts` doesn't exist.

**Step 3: Implement session detection**

Create `src/storage/session.ts`:

```typescript
import { createHash } from "node:crypto";

let cachedSessionId: string | null = null;

export function getSessionId(): string {
  if (cachedSessionId) return cachedSessionId;

  // Check env var first (Claude Code may expose this)
  const envSession = process.env.CLAUDE_SESSION_ID ?? process.env.SESSION_ID;
  if (envSession) {
    cachedSessionId = envSession;
    return cachedSessionId;
  }

  // Fallback: hash of pid + ppid + start time
  const raw = `${process.pid}-${process.ppid}-${Date.now()}`;
  cachedSessionId = createHash("sha256").update(raw).digest("hex").slice(0, 12);
  return cachedSessionId;
}
```

Update `src/tools/context-save.ts` — add `agent_id` to schema, auto-tag project + session_id:

```typescript
// Add to schema:
agent_id: z
  .string()
  .optional()
  .describe("Optional agent identifier (defaults to 'main')"),
```

In the `contextSave` function, before `index.insert(entry)`:

```typescript
import { getCurrentProject } from "../server.js";
import { getSessionId } from "../storage/session.js";

// Inside contextSave, before insert:
const enrichedEntry = {
  ...entry,
  project: getCurrentProject() ?? undefined,
  sessionId: getSessionId(),
  agentId: args.agent_id ?? "main",
};
const rowid = index.insert(enrichedEntry);
```

**Step 4: Run test to verify it passes**

Run: `npm run smoke-test`
Expected: PASS

**Step 5: Commit**

```bash
git add src/storage/session.ts src/tools/context-save.ts src/server.ts scripts/smoke-test.ts
git commit -m "feat: session ID detection + auto-tag project/session/agent on save"
```

---

### Task 4: Confidence Scoring in Search

**Files:**
- Modify: `src/storage/sqlite.ts` — `hybridSearch()` method (~line 195-245)

**Step 1: Write the failing test**

Add to `scripts/smoke-test.ts`:

```typescript
// -------------------------------------------------------
// 16. Test confidence scoring in search
// -------------------------------------------------------
console.log("\n[16] Confidence scoring");

// Create two entries: one with high access count, one with zero
index.clearAll();
const highAccess = makeEntry({ type: "decision", content: "Frequently accessed decision about API design patterns" });
const lowAccess = makeEntry({ type: "decision", content: "Never accessed decision about API caching strategy" });
highAccess.accessCount = 10;
lowAccess.accessCount = 0;

const haRowid = index.insert(highAccess);
const laRowid = index.insert(lowAccess);
const haEmb = await embedder.embed(highAccess.content);
const laEmb = await embedder.embed(lowAccess.content);
index.insertVec(haRowid, haEmb);
index.insertVec(laRowid, laEmb);

const qEmb = await embedder.embed("API design decision");
const confResults = index.hybridSearch("API design decision", qEmb, { limit: 10 });
assert(confResults.length === 2, `Confidence search returned 2 results`);
assert(
  confResults[0].id === highAccess.id,
  `High-access entry ranked first (got ${confResults[0].id === highAccess.id})`
);
```

**Step 2: Run test to verify it fails**

Run: `npm run smoke-test`
Expected: May pass incidentally due to other scoring — but the explicit confidence_boost multiplier isn't applied yet.

**Step 3: Implement confidence boost**

In `src/storage/sqlite.ts`, in the `hybridSearch()` method, add a `confidenceBoost` function and apply it in the scoring:

```typescript
const confidenceBoost = (accessCount: number): number => {
  if (accessCount === 0) return 0.7;
  if (accessCount <= 2) return 1.0;
  if (accessCount <= 5) return 1.2;
  return 1.4;
};

// In the scored mapping, change:
return { entry, score: (scores.get(rowid) ?? 0) * decay * tierWeight(entry.tier) };
// To:
return {
  entry,
  score: (scores.get(rowid) ?? 0) * decay * tierWeight(entry.tier) * confidenceBoost(entry.accessCount ?? 0),
};
```

**Step 4: Run test to verify it passes**

Run: `npm run smoke-test`
Expected: PASS

**Step 5: Commit**

```bash
git add src/storage/sqlite.ts scripts/smoke-test.ts
git commit -m "feat: confidence scoring — access_count influences search ranking"
```

---

### Task 5: Access-Aware Decay Windows

**Files:**
- Modify: `src/storage/sqlite.ts` — `decayEphemeral()` and `demoteIdle()` methods

**Step 1: Write the failing test**

Add to `scripts/smoke-test.ts`:

```typescript
// -------------------------------------------------------
// 17. Test access-aware decay windows
// -------------------------------------------------------
console.log("\n[17] Access-aware decay");

index.clearAll();

// Entry with 0 accesses, 4 days old — should be archived (new threshold: 3 days)
const zeroAccess = makeEntry({ type: "progress", content: "Zero access entry", tier: "ephemeral" });
zeroAccess.accessCount = 0;
index.insert(zeroAccess);

// Entry with 5 accesses, 4 days old — should NOT be archived (threshold: 14 days)
const highAccessEph = makeEntry({ type: "progress", content: "High access ephemeral", tier: "ephemeral" });
highAccessEph.accessCount = 5;
index.insert(highAccessEph);

const rawDb4 = new DatabaseSync(DB_PATH);
rawDb4.exec(`UPDATE entries SET date = date('now', '-4 days') WHERE id IN ('${zeroAccess.id}', '${highAccessEph.id}')`);
rawDb4.close();

const decayedCount = index.decayEphemeral();
assert(decayedCount >= 1, `Access-aware decay archived ${decayedCount} entry(ies)`);

const remaining = index.list();
const zeroStillThere = remaining.find(e => e.id === zeroAccess.id);
const highStillThere = remaining.find(e => e.id === highAccessEph.id);
assert(zeroStillThere === undefined, `Zero-access entry archived after 4 days`);
assert(highStillThere !== undefined, `High-access entry NOT archived after 4 days`);
```

**Step 2: Run test to verify it fails**

Run: `npm run smoke-test`
Expected: FAIL — current decay uses flat 7-day window.

**Step 3: Implement access-aware decay**

Replace `decayEphemeral()` in `src/storage/sqlite.ts`:

```typescript
/** Archive ephemeral entries based on access-aware windows */
decayEphemeral(): number {
  // 0 accesses: 3 days, 1-2 accesses: 7 days, 3+ accesses: 14 days
  const stmt = this.db.prepare(`
    UPDATE entries SET archived = 1
    WHERE tier = 'ephemeral' AND pinned = 0 AND archived = 0
      AND (
        (access_count = 0 AND date < date('now', '-3 days'))
        OR (access_count BETWEEN 1 AND 2 AND date < date('now', '-7 days'))
        OR (access_count >= 3 AND date < date('now', '-14 days'))
      )
  `);
  return Number(stmt.run().changes);
}
```

Replace `demoteIdle()`:

```typescript
/** Demote working entries based on access-aware idle windows */
demoteIdle(): number {
  // 0 accesses: 15 days, 1-2 accesses: 30 days, 3+ accesses: 60 days
  const stmt = this.db.prepare(`
    UPDATE entries SET tier = 'ephemeral'
    WHERE tier = 'working' AND pinned = 0 AND archived = 0
      AND (
        (access_count = 0 AND COALESCE(last_accessed, date) < date('now', '-15 days'))
        OR (access_count BETWEEN 1 AND 2 AND COALESCE(last_accessed, date) < date('now', '-30 days'))
        OR (access_count >= 3 AND COALESCE(last_accessed, date) < date('now', '-60 days'))
      )
  `);
  return Number(stmt.run().changes);
}
```

Note: remove the `daysOld` and `idleDays` parameters since the logic is now baked in.

Update `maintenance.ts` to call without args:

```typescript
export function runMaintenance(index: ContextIndex): MaintenanceReport {
  const decayed = index.decayEphemeral();
  const demoted = index.demoteIdle();
  const promotedStable = index.promoteStable();
  const promotedFrequent = index.promoteFrequent();
  return { decayed, demoted, promotedStable, promotedFrequent };
}
```

**Step 4: Run test to verify it passes**

Run: `npm run smoke-test`
Expected: PASS

**Step 5: Commit**

```bash
git add src/storage/sqlite.ts src/storage/maintenance.ts scripts/smoke-test.ts
git commit -m "feat: access-aware decay — unused entries fade faster, used entries persist longer"
```

---

### Task 6: Co-Change Pair Generation During Git Indexing

**Files:**
- Modify: `src/storage/sqlite.ts` — add `upsertFilePair()` and `getCoChanges()` methods
- Modify: `src/tools/context-git-index.ts` — generate pairs from commits

**Step 1: Write the failing test**

Add to `scripts/smoke-test.ts`:

```typescript
// -------------------------------------------------------
// 18. Test co-change pair generation
// -------------------------------------------------------
console.log("\n[18] Co-change pairs");

index.clearAll();

// Simulate upsertFilePair
index.upsertFilePair("test-project", "src/a.ts", "src/b.ts", "2026-02-15");
index.upsertFilePair("test-project", "src/a.ts", "src/b.ts", "2026-02-15");
index.upsertFilePair("test-project", "src/a.ts", "src/c.ts", "2026-02-15");

const cochanges = index.getCoChanges("test-project", "src/a.ts", 10);
assert(cochanges.length === 2, `getCoChanges returned 2 pairs (got ${cochanges.length})`);
assert(cochanges[0].file === "src/b.ts" && cochanges[0].count === 2, `First pair is b.ts with count 2`);
assert(cochanges[1].file === "src/c.ts" && cochanges[1].count === 1, `Second pair is c.ts with count 1`);
```

**Step 2: Run test to verify it fails**

Run: `npm run smoke-test`
Expected: FAIL — `upsertFilePair` and `getCoChanges` don't exist.

**Step 3: Implement co-change methods**

Add to `src/storage/sqlite.ts`:

```typescript
upsertFilePair(project: string, fileA: string, fileB: string, date: string): void {
  // Ensure consistent ordering (a < b) to avoid duplicates
  const [f1, f2] = fileA < fileB ? [fileA, fileB] : [fileB, fileA];
  this.db.prepare(`
    INSERT INTO file_pairs (project, file_a, file_b, co_change_count, last_seen)
    VALUES (?, ?, ?, 1, ?)
    ON CONFLICT(project, file_a, file_b) DO UPDATE SET
      co_change_count = co_change_count + 1,
      last_seen = ?
  `).run(project, f1, f2, date, date);
}

getCoChanges(
  project: string,
  file: string,
  limit: number = 10
): Array<{ file: string; count: number; lastSeen: string }> {
  const rows = this.db.prepare(`
    SELECT
      CASE WHEN file_a = ? THEN file_b ELSE file_a END as paired_file,
      co_change_count,
      last_seen
    FROM file_pairs
    WHERE project = ? AND (file_a = ? OR file_b = ?)
    ORDER BY co_change_count DESC
    LIMIT ?
  `).all(file, project, file, file, limit) as Array<Record<string, unknown>>;

  return rows.map(r => ({
    file: r.paired_file as string,
    count: r.co_change_count as number,
    lastSeen: r.last_seen as string,
  }));
}
```

Update `src/tools/context-git-index.ts` — after indexing each commit, generate file pairs:

```typescript
import { getCurrentProject } from "../server.js";

// Inside the for loop, after embedding the commit, add:
// Generate co-change pairs (skip commits with 20+ files)
const project = getCurrentProject();
if (project && commit.files.length >= 2 && commit.files.length < 20) {
  const filePaths = commit.files.map(f => f.path);
  for (let i = 0; i < filePaths.length; i++) {
    for (let j = i + 1; j < filePaths.length; j++) {
      index.upsertFilePair(project, filePaths[i], filePaths[j], commit.date);
    }
  }
}
```

**Step 4: Run test to verify it passes**

Run: `npm run smoke-test`
Expected: PASS

**Step 5: Commit**

```bash
git add src/storage/sqlite.ts src/tools/context-git-index.ts scripts/smoke-test.ts
git commit -m "feat: co-change pair generation from git commits"
```

---

### Task 7: `context_session` Tool

**Files:**
- Create: `src/tools/context-session.ts`
- Modify: `src/server.ts` — register new tool
- Modify: `src/storage/sqlite.ts` — add `listBySession()` method

**Step 1: Write the failing test**

Add to `scripts/smoke-test.ts`:

```typescript
// -------------------------------------------------------
// 19. Test context_session tool
// -------------------------------------------------------
console.log("\n[19] context_session");

index.clearAll();

// Insert entries with session_id
const sessionEntries = [
  makeEntry({ type: "decision", content: "Session decision 1" }),
  makeEntry({ type: "insight", content: "Session insight 1" }),
  makeEntry({ type: "progress", content: "Different session progress" }),
];
index.insert({ ...sessionEntries[0], sessionId: "sess-abc" });
index.insert({ ...sessionEntries[1], sessionId: "sess-abc" });
index.insert({ ...sessionEntries[2], sessionId: "sess-xyz" });

const sessionResults = index.listBySession("sess-abc");
assert(sessionResults.length === 2, `listBySession returned 2 entries for sess-abc (got ${sessionResults.length})`);
assert(sessionResults.every(e => (e as any).sessionId === "sess-abc"), `All results have session_id = sess-abc`);
```

**Step 2: Run test to verify it fails**

Run: `npm run smoke-test`
Expected: FAIL — `listBySession` doesn't exist.

**Step 3: Implement**

Add to `src/storage/sqlite.ts`:

```typescript
listBySession(
  sessionId: string,
  opts: { type?: string } = {}
): ContextEntry[] {
  const conditions = ["session_id = ?"];
  const params: (string | number)[] = [sessionId];

  if (opts.type) {
    conditions.push("type = ?");
    params.push(opts.type);
  }

  const sql = `
    SELECT id, date, time, type, tags, content, source_file, tier, access_count,
           last_accessed, pinned, archived, project, session_id, agent_id
    FROM entries
    WHERE ${conditions.join(" AND ")}
    ORDER BY date ASC, time ASC
  `;

  const rows = this.db.prepare(sql).all(...params) as Record<string, unknown>[];
  return rows.map((row) => ({
    id: row.id as string,
    date: row.date as string,
    time: row.time as string,
    type: row.type as string,
    tags: (row.tags as string).split(", ").filter(Boolean),
    content: row.content as string,
    sourceFile: row.source_file as string,
    tier: row.tier as ContextEntry["tier"],
    accessCount: row.access_count as number,
    lastAccessed: row.last_accessed as string | null,
    pinned: !!(row.pinned as number),
    archived: !!(row.archived as number),
    project: row.project as string | null,
    sessionId: row.session_id as string | null,
    agentId: row.agent_id as string | null,
  }));
}
```

Create `src/tools/context-session.ts`:

```typescript
import { z } from "zod";
import { ContextIndex } from "../storage/sqlite.js";
import { getSessionId } from "../storage/session.js";

export const contextSessionSchema = {
  session_id: z
    .string()
    .optional()
    .describe("Session ID to query. Defaults to current session."),
  type: z
    .enum(["decision", "progress", "issue", "handoff", "insight", "reference", "git_commit", "rule"])
    .optional()
    .describe("Filter by entry type"),
};

export function contextSession(
  args: { session_id?: string; type?: string },
  index: ContextIndex
): { entries: Array<Record<string, unknown>>; total: number } {
  const sessionId = args.session_id ?? getSessionId();
  const results = index.listBySession(sessionId, { type: args.type });

  return {
    entries: results.map(r => ({
      id: r.id,
      date: r.date,
      time: r.time,
      type: r.type,
      tags: r.tags,
      content: r.content,
      agent_id: (r as any).agentId ?? null,
    })),
    total: results.length,
  };
}
```

Register in `src/server.ts`:

```typescript
import { contextSession, contextSessionSchema } from "./tools/context-session.js";

// Add in createServer():
server.tool(
  "context_session",
  "List all entries from the current or specified session. Use for agent context sharing.",
  contextSessionSchema,
  async (args) => {
    const result = contextSession(args, index);
    return {
      content: [{ type: "text", text: JSON.stringify(result, null, 2) }],
    };
  }
);
```

**Step 4: Run test to verify it passes**

Run: `npm run smoke-test`
Expected: PASS

**Step 5: Commit**

```bash
git add src/tools/context-session.ts src/storage/sqlite.ts src/server.ts scripts/smoke-test.ts
git commit -m "feat: context_session tool for agent context sharing"
```

---

### Task 8: `context_cochanges` Tool

**Files:**
- Create: `src/tools/context-cochanges.ts`
- Modify: `src/server.ts` — register new tool

**Step 1: Write the failing test**

The `getCoChanges()` method was already tested in Task 6. This task just wraps it as an MCP tool.

**Step 2: Implement**

Create `src/tools/context-cochanges.ts`:

```typescript
import { z } from "zod";
import { ContextIndex } from "../storage/sqlite.js";
import { getCurrentProject } from "../server.js";

export const contextCochangesSchema = {
  file: z.string().describe("File path to look up co-changes for"),
  project: z
    .string()
    .optional()
    .describe("Project name. Defaults to current project."),
  limit: z
    .number()
    .int()
    .positive()
    .max(50)
    .default(10)
    .describe("Maximum results to return"),
};

export function contextCochanges(
  args: { file: string; project?: string; limit?: number },
  index: ContextIndex
): { file: string; project: string | null; cochanges: Array<{ file: string; count: number; lastSeen: string }> } {
  const project = args.project ?? getCurrentProject();
  if (!project) {
    return { file: args.file, project: null, cochanges: [] };
  }

  const cochanges = index.getCoChanges(project, args.file, args.limit ?? 10);
  return { file: args.file, project, cochanges };
}
```

Register in `src/server.ts`:

```typescript
import { contextCochanges, contextCochangesSchema } from "./tools/context-cochanges.js";

server.tool(
  "context_cochanges",
  "Get files that frequently co-change with a given file, based on git history.",
  contextCochangesSchema,
  async (args) => {
    const result = contextCochanges(args, index);
    return {
      content: [{ type: "text", text: JSON.stringify(result, null, 2) }],
    };
  }
);
```

**Step 3: Run test**

Run: `npm run smoke-test`
Expected: PASS (no new test failures)

**Step 4: Commit**

```bash
git add src/tools/context-cochanges.ts src/server.ts
git commit -m "feat: context_cochanges tool — query file co-change relationships"
```

---

### Task 9: Wave 1 Integration Test + Version Bump

**Files:**
- Modify: `scripts/smoke-test.ts` — ensure all Wave 1 tests pass end-to-end
- Modify: `package.json` — bump version hint
- Modify: `src/server.ts` — bump version

**Step 1: Run full smoke test**

Run: `npm run smoke-test`
Expected: ALL PASS

**Step 2: Commit Wave 1 completion**

```bash
git add -A
git commit -m "chore: complete Wave 1 — data foundation for v0.5.0"
```

---

## Wave 2 — Smarter Hooks

### Task 10: Pre-Computed Template Embeddings

**Files:**
- Modify: `src/storage/embedder.ts` — add `getTemplateEmbeddings()` method

**Step 1: Write the failing test**

Add to `scripts/smoke-test.ts`:

```typescript
// -------------------------------------------------------
// 20. Test template embeddings
// -------------------------------------------------------
console.log("\n[20] Template embeddings");

const templates = await embedder.getDirectiveTemplates();
assert(templates.length > 0, `Directive templates loaded (got ${templates.length})`);
assert(templates[0].embedding.length === 384, `Template embedding is 384-dim`);

const categoryTemplates = await embedder.getCategoryTemplates();
assert(categoryTemplates.length > 0, `Category templates loaded (got ${categoryTemplates.length})`);
```

**Step 2: Run test to verify it fails**

Run: `npm run smoke-test`
Expected: FAIL — methods don't exist.

**Step 3: Implement template embeddings**

Add to `src/storage/embedder.ts`:

```typescript
interface TemplateEmbedding {
  category: string;
  text: string;
  embedding: Float32Array;
}

private directiveTemplates: TemplateEmbedding[] | null = null;
private categoryTemplates: TemplateEmbedding[] | null = null;

/** Pre-computed directive templates for correction detection */
async getDirectiveTemplates(): Promise<TemplateEmbedding[]> {
  if (this.directiveTemplates) return this.directiveTemplates;

  const directives = [
    { category: "always", text: "always do this from now on" },
    { category: "never", text: "never do that again" },
    { category: "stop", text: "stop doing this please" },
    { category: "remember", text: "please remember to do this going forward" },
    { category: "preference", text: "I prefer this approach instead" },
    { category: "correction", text: "that's wrong, do it this way instead" },
  ];

  this.directiveTemplates = [];
  for (const d of directives) {
    const embedding = await this.embed(d.text);
    this.directiveTemplates.push({ ...d, embedding });
  }
  return this.directiveTemplates;
}

/** Pre-computed category templates for distillation */
async getCategoryTemplates(): Promise<TemplateEmbedding[]> {
  if (this.categoryTemplates) return this.categoryTemplates;

  const categories = [
    { category: "decision", text: "we decided to go with this approach" },
    { category: "decision", text: "let's use this option instead" },
    { category: "solution", text: "the fix was to change this" },
    { category: "solution", text: "this worked because of that reason" },
    { category: "discovery", text: "turns out the issue was caused by this" },
    { category: "discovery", text: "I found out that this is how it works" },
  ];

  this.categoryTemplates = [];
  for (const c of categories) {
    const embedding = await this.embed(c.text);
    this.categoryTemplates.push({ ...c, embedding });
  }
  return this.categoryTemplates;
}

/** Classify a sentence against templates, return best match if above threshold */
async classifySentence(
  sentence: string,
  templates: TemplateEmbedding[],
  threshold: number = 0.7
): Promise<{ category: string; similarity: number } | null> {
  const sentenceEmb = await this.embed(sentence);
  let bestMatch: { category: string; similarity: number } | null = null;

  for (const tpl of templates) {
    let dot = 0;
    for (let i = 0; i < sentenceEmb.length; i++) {
      dot += sentenceEmb[i] * tpl.embedding[i];
    }
    // Embeddings are L2-normalized, so dot product = cosine similarity
    if (dot >= threshold && (!bestMatch || dot > bestMatch.similarity)) {
      bestMatch = { category: tpl.category, similarity: dot };
    }
  }
  return bestMatch;
}
```

**Step 4: Run test to verify it passes**

Run: `npm run smoke-test`
Expected: PASS

**Step 5: Commit**

```bash
git add src/storage/embedder.ts scripts/smoke-test.ts
git commit -m "feat: pre-computed template embeddings for distillation + correction detection"
```

---

### Task 11: Session-Start — Project-Aware Filtering

**Files:**
- Modify: `src/hooks/session-start.ts` — filter recent context by project, increase token budget

**Step 1: Implement**

In `src/hooks/session-start.ts`:

1. Import `detectProject` and call it early:
```typescript
import { detectProject } from "../storage/project.js";
const currentProject = detectProject();
```

2. Change `TOKEN_BUDGET_CHARS` from 3200 to 4000.

3. In the recent context section, add project boosting — show same-project entries first:
```typescript
const recent = index.list({ days: 3 })
  .filter(e => e.tier !== "ephemeral" && e.type !== "handoff" && e.type !== "rule")
  .sort((a, b) => {
    // Same project first
    const aMatch = (a as any).project === currentProject ? 1 : 0;
    const bMatch = (b as any).project === currentProject ? 1 : 0;
    if (aMatch !== bMatch) return bMatch - aMatch;
    // Then by date/time desc
    return 0; // already sorted by date desc from list()
  });
```

**Step 2: Build and verify no errors**

Run: `npm run build`
Expected: No compilation errors.

**Step 3: Commit**

```bash
git add src/hooks/session-start.ts
git commit -m "feat: session-start project-aware filtering + 4000 char token budget"
```

---

### Task 12: Session-Start — Git Activity + Related Context

**Files:**
- Modify: `src/hooks/session-start.ts` — add git activity analysis section
- Modify: `src/storage/git.ts` — add `getRecentlyChangedFiles()` helper

**Step 1: Implement git helper**

Add to `src/storage/git.ts`:

```typescript
export function getRecentlyChangedFiles(repoPath: string): string[] {
  const files = new Set<string>();
  try {
    // Last 3 commits
    const committed = execSync("git diff --name-only HEAD~3", {
      cwd: repoPath,
      encoding: "utf-8",
      timeout: 3000,
    }).trim();
    if (committed) committed.split("\n").forEach(f => files.add(f));
  } catch {
    // May fail if fewer than 3 commits
  }
  try {
    // Uncommitted changes
    const uncommitted = execSync("git diff --name-only", {
      cwd: repoPath,
      encoding: "utf-8",
      timeout: 3000,
    }).trim();
    if (uncommitted) uncommitted.split("\n").forEach(f => files.add(f));
  } catch {
    // Ignore
  }
  return Array.from(files);
}
```

**Step 2: Add related context section to session-start**

In `src/hooks/session-start.ts`, after the existing sections, add a new budgetForRelated section:

```typescript
import { getRecentlyChangedFiles, isGitRepo } from "../storage/git.js";

// After git index, before assembling sections:
const budgetForRelated: string[] = [];
const cwd = process.cwd();
if (isGitRepo(cwd)) {
  const recentFiles = getRecentlyChangedFiles(cwd);
  if (recentFiles.length > 0) {
    // Search for entries related to recently changed files
    const fileQuery = recentFiles.slice(0, 5).join(" ");
    try {
      const related = index.search(fileQuery, { limit: 3 })
        .filter(e => e.type !== "handoff" && e.type !== "git_commit");
      if (related.length > 0) {
        budgetForRelated.push("## Related context");
        for (const r of related) {
          const ago = Math.floor((Date.now() - new Date(r.date).getTime()) / (1000 * 60 * 60 * 24));
          budgetForRelated.push(`- [${ago}d ago] ${r.content.slice(0, 120)}`);
        }
        budgetForRelated.push("");
      }
    } catch {
      // Don't block session start
    }
  }
}
```

Add `budgetForRelated` to the sections array.

**Step 3: Build and verify**

Run: `npm run build`
Expected: No errors.

**Step 4: Commit**

```bash
git add src/storage/git.ts src/hooks/session-start.ts
git commit -m "feat: session-start git activity analysis + related past context injection"
```

---

### Task 13: Stop Hook — New Handoff Format with Learnings

**Files:**
- Modify: `src/hooks/stop.ts` — new handoff format with activity + learnings

**Step 1: Implement new handoff format**

Replace the handoff content generation section in `src/hooks/stop.ts`:

```typescript
import { detectProject } from "../storage/project.js";

// After collecting todayEntries:
const project = detectProject();

// Collect real-time insight saves from today (the primary distillation source)
const todayInsights = todayEntries
  .filter(e => e.type === "insight" && e.type !== "handoff")
  .slice(0, 5);

const typeSummary = Array.from(types.entries())
  .map(([t, c]) => `${c} ${t}`)
  .join(", ");

const contentParts: string[] = [];

// Activity line
const projects = new Set(todayEntries.map(e => (e as any).project).filter(Boolean));
const projectStr = projects.size > 0 ? ` across ${Array.from(projects).join(", ")}` : "";
contentParts.push(`Activity: ${todayEntries.length} entries${projectStr}.`);

// Learnings section (from real-time insight saves)
if (todayInsights.length > 0) {
  contentParts.push("Learnings:");
  for (const insight of todayInsights) {
    const summary = insight.content.length > 150
      ? insight.content.slice(0, 150) + "..."
      : insight.content;
    contentParts.push(`- ${summary}`);
  }
}

const content = contentParts.join("\n");
```

**Step 2: Build and verify**

Run: `npm run build`
Expected: No errors.

**Step 3: Commit**

```bash
git add src/hooks/stop.ts
git commit -m "feat: stop hook — new handoff format with activity + learnings"
```

---

### Task 14: Stop Hook — Embedder-Based Safety Net + Correction Detection

**Files:**
- Modify: `src/hooks/stop.ts` — add Layer 2 sentence classification + correction detection

**Step 1: Implement sentence classification in stop hook**

Add after the learnings section in `src/hooks/stop.ts`:

```typescript
// Layer 2: Embedder safety net — classify remaining conversation for missed learnings
// Note: The stop hook receives limited context. This processes today's saved entries
// that aren't already insights, looking for missed decision/solution/discovery content.
try {
  const nonInsightEntries = todayEntries
    .filter(e => e.type !== "insight" && e.type !== "handoff" && e.type !== "git_commit" && e.type !== "rule");

  if (nonInsightEntries.length > 0 && todayInsights.length < 5) {
    const categoryTemplates = await embedder.getCategoryTemplates();
    const remaining = 5 - todayInsights.length;
    const candidates: Array<{ content: string; category: string; similarity: number }> = [];

    for (const entry of nonInsightEntries.slice(0, 20)) {
      const match = await embedder.classifySentence(entry.content, categoryTemplates, 0.7);
      if (match) {
        candidates.push({ content: entry.content, ...match });
      }
    }

    // Sort by similarity, take top N
    candidates.sort((a, b) => b.similarity - a.similarity);
    const extras = candidates.slice(0, remaining);
    if (extras.length > 0 && todayInsights.length === 0) {
      contentParts.push("Learnings:");
    }
    for (const extra of extras) {
      const summary = extra.content.length > 150 ? extra.content.slice(0, 150) + "..." : extra.content;
      contentParts.push(`- ${summary}`);
    }
  }

  // Correction detection — scan for directive patterns, save as pending rules
  const directiveTemplates = await embedder.getDirectiveTemplates();
  const corrections: Array<{ content: string; category: string }> = [];

  for (const entry of todayEntries.filter(e => e.tags.includes("correction"))) {
    corrections.push({ content: entry.content, category: "explicit" });
  }

  // Also check non-tagged entries for directive language
  for (const entry of nonInsightEntries.slice(0, 15)) {
    const match = await embedder.classifySentence(entry.content, directiveTemplates, 0.75);
    if (match && !corrections.some(c => c.content === entry.content)) {
      corrections.push({ content: entry.content, category: match.category });
    }
  }

  // Save corrections as pending rule proposals
  if (corrections.length > 0) {
    for (const corr of corrections.slice(0, 3)) {
      const label = corr.content.slice(0, 40).toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/-+$/, "");
      const pendingEntry = appendEntry(
        corr.content,
        "insight",
        ["pending_rule", `proposed-label:${label}`]
      );
      pendingEntry.tier = "working";
      index.insert(pendingEntry);
      const emb = await embedder.embed(corr.content);
      index.insertVec(index.insert(pendingEntry), emb);
    }
    contentParts.push(`Corrections detected: ${corrections.length} pending rule proposal(s) saved.`);
  }
} catch {
  // Don't fail the handoff if classification errors
}
```

**Step 2: Build and verify**

Run: `npm run build`
Expected: No errors.

**Step 3: Commit**

```bash
git add src/hooks/stop.ts
git commit -m "feat: stop hook — embedder safety net for missed learnings + correction detection"
```

---

### Task 15: Install Auto-Distill Rule

**Files:**
- Modify: `src/hooks/session-start.ts` — auto-install the rule on first run

**Step 1: Implement**

In `src/hooks/session-start.ts`, after creating the ContextIndex, check if the auto-distill rule exists:

```typescript
// Auto-install the auto-distill rule if not present
const rules = index.listRules();
const hasAutoDistill = rules.some(r => r.label === "auto-distill");
if (!hasAutoDistill) {
  index.saveRule(
    "auto-distill",
    "When a significant decision is made, a problem is solved, a correction is given, or something surprising is discovered, save it as an insight to Synaptic immediately using context_save. Tag corrections with 'correction'. Don't wait for session end."
  );
}
```

**Step 2: Build and verify**

Run: `npm run build`
Expected: No errors.

**Step 3: Commit**

```bash
git add src/hooks/session-start.ts
git commit -m "feat: auto-install auto-distill rule on first session"
```

---

### Task 16: Wave 2 Smoke Tests + Commit

**Step 1: Run full smoke test**

Run: `npm run smoke-test`
Expected: ALL PASS

**Step 2: Commit**

```bash
git add -A
git commit -m "chore: complete Wave 2 — smarter hooks for v0.5.0"
```

---

## Wave 3 — Intelligence

### Task 17: Session-Start — Co-Change Suggestions

**Files:**
- Modify: `src/hooks/session-start.ts` — add co-change section

**Step 1: Implement**

In `src/hooks/session-start.ts`, in the git activity section, after getting `recentFiles`:

```typescript
// Co-change suggestions
const budgetForCochanges: string[] = [];
if (currentProject && recentFiles.length > 0) {
  const suggestions: string[] = [];
  for (const file of recentFiles.slice(0, 5)) {
    const cochanges = index.getCoChanges(currentProject, file, 3)
      .filter(c => c.count >= 3 && !recentFiles.includes(c.file));
    if (cochanges.length > 0) {
      const pairs = cochanges.map(c => `${c.file} (${c.count}x)`).join(", ");
      suggestions.push(`- ${file} → usually also changes: ${pairs}`);
    }
  }
  if (suggestions.length > 0) {
    budgetForCochanges.push("## Predictive context");
    budgetForCochanges.push(...suggestions);
    budgetForCochanges.push("");
  }
}
```

Add `budgetForCochanges` to the sections array.

**Step 2: Build and verify**

Run: `npm run build`
Expected: No errors.

**Step 3: Commit**

```bash
git add src/hooks/session-start.ts
git commit -m "feat: session-start co-change suggestions for recently touched files"
```

---

### Task 18: Session-Start — Cross-Project Surfacing

**Files:**
- Modify: `src/hooks/session-start.ts`

**Step 1: Implement**

Add a new section after recent context:

```typescript
// Cross-project insights
const budgetForCrossProject: string[] = [];
if (currentProject) {
  const crossProject = index.list({ days: 7 })
    .filter(e =>
      (e as any).project !== null &&
      (e as any).project !== currentProject &&
      e.type !== "handoff" &&
      e.type !== "git_commit" &&
      e.tier !== "ephemeral"
    )
    .slice(0, 3);

  if (crossProject.length > 0) {
    budgetForCrossProject.push("## From other projects");
    for (const entry of crossProject) {
      budgetForCrossProject.push(`- [${(entry as any).project}] ${entry.content.slice(0, 120)}`);
    }
    budgetForCrossProject.push("");
  }
}
```

Add to sections array.

**Step 2: Build and verify**

Run: `npm run build`
Expected: No errors.

**Step 3: Commit**

```bash
git add src/hooks/session-start.ts
git commit -m "feat: session-start cross-project insight surfacing"
```

---

### Task 19: Session-Start — Pending Rule Approval

**Files:**
- Modify: `src/hooks/session-start.ts`

**Step 1: Implement**

Add a section after rules:

```typescript
// Pending rules for approval
const budgetForPending: string[] = [];
const pendingRules = index.list({ days: 7 })
  .filter(e => e.tags.includes("pending_rule") && !e.archived);

if (pendingRules.length > 0) {
  budgetForPending.push("## Pending rules (approve or dismiss)");
  for (const pr of pendingRules.slice(0, 3)) {
    const labelTag = pr.tags.find(t => t.startsWith("proposed-label:"));
    const label = labelTag ? labelTag.replace("proposed-label:", "") : "unnamed";
    budgetForPending.push(`- "${label}": ${pr.content.slice(0, 100)}`);
  }
  budgetForPending.push("_Ask user to accept (context_save_rule) or dismiss (context_archive)._");
  budgetForPending.push("");
}
```

Insert this into the sections assembly right after rules (high priority).

**Step 2: Build and verify**

Run: `npm run build`
Expected: No errors.

**Step 3: Commit**

```bash
git add src/hooks/session-start.ts
git commit -m "feat: session-start pending rule approval prompts"
```

---

### Task 20: Conflict Detection

**Files:**
- Modify: `src/hooks/stop.ts` — check new corrections against existing rules

**Step 1: Implement**

In the correction detection section of `src/hooks/stop.ts`, before saving pending rules, check for conflicts:

```typescript
// Check for conflicts with existing rules
const existingRules = index.listRules();
if (existingRules.length > 0 && corrections.length > 0) {
  for (const corr of corrections) {
    const corrEmb = await embedder.embed(corr.content);
    for (const rule of existingRules) {
      const ruleEmb = await embedder.embed(rule.content);
      // Cosine similarity (both L2-normalized)
      let dot = 0;
      for (let i = 0; i < corrEmb.length; i++) {
        dot += corrEmb[i] * ruleEmb[i];
      }
      if (dot >= 0.7) {
        // Conflict detected — save as conflict entry
        const conflictEntry = appendEntry(
          `Conflict: new correction "${corr.content.slice(0, 80)}" may contradict rule "${rule.label}": "${rule.content.slice(0, 80)}"`,
          "insight",
          ["rule_conflict", `conflicts-with:${rule.label}`]
        );
        conflictEntry.tier = "working";
        const conflictRowid = index.insert(conflictEntry);
        const conflictEmb = await embedder.embed(conflictEntry.content);
        index.insertVec(conflictRowid, conflictEmb);
      }
    }
  }
}
```

In `src/hooks/session-start.ts`, surface conflicts:

```typescript
// Rule conflicts
const conflicts = index.list({ days: 7 })
  .filter(e => e.tags.includes("rule_conflict") && !e.archived);

if (conflicts.length > 0) {
  // Insert into pending rules section
  for (const c of conflicts.slice(0, 2)) {
    budgetForPending.push(`- CONFLICT: ${c.content.slice(0, 120)}`);
  }
}
```

**Step 2: Build and verify**

Run: `npm run build`
Expected: No errors.

**Step 3: Commit**

```bash
git add src/hooks/stop.ts src/hooks/session-start.ts
git commit -m "feat: conflict detection between corrections and existing rules"
```

---

### Task 21: Wave 3 Smoke Tests + Final Version Bump

**Files:**
- Modify: `scripts/smoke-test.ts` — add Wave 3 integration tests
- Modify: `package.json` — version 0.5.0
- Modify: `src/server.ts` — version 0.5.0

**Step 1: Add smoke tests for co-changes, cross-project, pending rules**

Add comprehensive tests for the Wave 3 features to `scripts/smoke-test.ts`.

**Step 2: Bump version**

In `package.json`: `"version": "0.5.0"`
In `src/server.ts`: `version: "0.5.0"`

**Step 3: Run full smoke test**

Run: `npm run smoke-test`
Expected: ALL PASS

**Step 4: Final commit**

```bash
git add -A
git commit -m "chore: bump version to 0.5.0 — Intelligence Layer complete"
```

---

## Summary

| Task | Wave | Description |
|------|------|-------------|
| 1 | 1 | Schema migration (3 cols + file_pairs) |
| 2 | 1 | Project auto-detection |
| 3 | 1 | Session ID + auto-tagging on save |
| 4 | 1 | Confidence scoring in search |
| 5 | 1 | Access-aware decay windows |
| 6 | 1 | Co-change pair generation |
| 7 | 1 | `context_session` tool |
| 8 | 1 | `context_cochanges` tool |
| 9 | 1 | Wave 1 integration test |
| 10 | 2 | Template embeddings |
| 11 | 2 | Session-start project filtering |
| 12 | 2 | Session-start git activity + related context |
| 13 | 2 | Stop hook new handoff format |
| 14 | 2 | Stop hook embedder safety net + corrections |
| 15 | 2 | Install auto-distill rule |
| 16 | 2 | Wave 2 smoke tests |
| 17 | 3 | Co-change suggestions in injection |
| 18 | 3 | Cross-project surfacing |
| 19 | 3 | Pending rule approval |
| 20 | 3 | Conflict detection |
| 21 | 3 | Final smoke tests + version bump |

**Total: 21 tasks across 3 waves. 2 new tools. 3 new columns. 1 new table. 1 new rule.**
