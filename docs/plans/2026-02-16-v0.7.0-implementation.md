# v0.7.0 Proactive Intelligence — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Make Synaptic autonomously capture declarations, predict session focus, consolidate duplicates, and reward important entries — without user prompting.

**Architecture:** Extends existing embedder with intent templates, upgrades stop hook with intent classification + access bumps, replaces session-start's related/predictive sections with a unified predicted focus section, and wires up the existing consolidation engine in maintenance.

**Tech Stack:** TypeScript, Node 22 built-in SQLite, Xenova/all-MiniLM-L6-v2 embedder, MCP SDK

---

### Task 1: Add `touchEntry()` to sqlite.ts

**Files:**
- Modify: `src/storage/sqlite.ts` (add method near other entry operations)
- Test: `scripts/smoke-test.ts`

**Step 1: Write the failing test**

Add after test section [17] in `scripts/smoke-test.ts`:

```typescript
// -------------------------------------------------------
// 28. Test touchEntry
// -------------------------------------------------------
console.log("\n[28] touchEntry");

index.clearAll();

const touchTarget = makeEntry({ type: "insight", content: "Entry to be touched for access bump" });
index.insert(touchTarget);

// Verify initial state
const beforeTouch = index.list().find(e => e.id === touchTarget.id);
assert(beforeTouch !== undefined && beforeTouch.accessCount === 0, `Before touch: accessCount=0 (got ${beforeTouch?.accessCount})`);
assert(beforeTouch!.lastAccessed === null, `Before touch: lastAccessed=null`);

// Touch it
index.touchEntry(touchTarget.id);

const afterTouch = index.list().find(e => e.id === touchTarget.id);
assert(afterTouch !== undefined && afterTouch.accessCount === 1, `After touch: accessCount=1 (got ${afterTouch?.accessCount})`);
assert(afterTouch!.lastAccessed !== null, `After touch: lastAccessed is set`);

// Touch again
index.touchEntry(touchTarget.id);
const afterSecondTouch = index.list().find(e => e.id === touchTarget.id);
assert(afterSecondTouch!.accessCount === 2, `After second touch: accessCount=2 (got ${afterSecondTouch?.accessCount})`);
```

**Step 2: Run test to verify it fails**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run smoke-test`
Expected: FAIL — `touchEntry` is not a function

**Step 3: Write minimal implementation**

Add to `src/storage/sqlite.ts` in the `ContextIndex` class, near `bumpAccess()`:

```typescript
/** Increment access_count and set last_accessed for a given entry ID */
touchEntry(id: string): boolean {
  const today = new Date().toISOString().slice(0, 10);
  const result = this.db.prepare(
    "UPDATE entries SET access_count = access_count + 1, last_accessed = ? WHERE id = ? AND archived = 0"
  ).run(today, id);
  return result.changes > 0;
}
```

**Step 4: Run test to verify it passes**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run smoke-test`
Expected: PASS — all tests including new [28]

**Step 5: Commit**

```bash
cd /home/hyperlynq/projects/Coding/claude-context-tool
git add src/storage/sqlite.ts scripts/smoke-test.ts
git commit -m "feat: add touchEntry() for access bumps without search"
```

---

### Task 2: Add intent templates to embedder.ts

**Files:**
- Modify: `src/storage/embedder.ts` (add `getIntentTemplates()`)
- Test: `scripts/smoke-test.ts`

**Step 1: Write the failing test**

Add after test section [28]:

```typescript
// -------------------------------------------------------
// 29. Intent templates
// -------------------------------------------------------
console.log("\n[29] Intent templates");

const intentTemplates = await embedder.getIntentTemplates();
assert(intentTemplates.length >= 10, `Intent templates loaded (got ${intentTemplates.length})`);
assert(intentTemplates[0].embedding.length === 384, `Intent template embedding is 384-dim`);

// Test classification of a declaration
const declResult = await embedder.classifySentence("wholesale harmony is my app", intentTemplates, 0.6);
assert(declResult !== null, `"wholesale harmony is my app" matches an intent template`);
assert(
  declResult!.category === "declaration" || declResult!.category === "ownership",
  `Matched category is declaration or ownership (got ${declResult?.category})`
);

// Test classification of a preference
const prefResult = await embedder.classifySentence("I prefer using typescript over javascript", intentTemplates, 0.6);
assert(prefResult !== null, `Preference statement matches an intent template`);
assert(prefResult!.category === "preference", `Matched category is preference (got ${prefResult?.category})`);

// Test that a random technical statement does NOT match
const noMatch = await embedder.classifySentence("The function returns a promise that resolves to an array", intentTemplates, 0.6);
// This may or may not match — just verify no crash
assert(true, `Random statement classification did not crash (result: ${noMatch?.category ?? "null"})`);
```

**Step 2: Run test to verify it fails**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run smoke-test`
Expected: FAIL — `getIntentTemplates` is not a function

**Step 3: Write minimal implementation**

Add to `src/storage/embedder.ts` in the `Embedder` class:

```typescript
private intentTemplates: TemplateEmbedding[] | null = null;

/** Pre-computed intent templates for autonomous capture */
async getIntentTemplates(): Promise<TemplateEmbedding[]> {
  if (this.intentTemplates) return this.intentTemplates;

  const intents = [
    { category: "declaration", text: "this is my project" },
    { category: "declaration", text: "that's my app" },
    { category: "declaration", text: "I built this" },
    { category: "declaration", text: "this is called my tool" },
    { category: "identity", text: "my name is" },
    { category: "identity", text: "my username is" },
    { category: "identity", text: "my account name is" },
    { category: "preference", text: "I like using this tool" },
    { category: "preference", text: "I usually do it this way" },
    { category: "preference", text: "I prefer this approach" },
    { category: "frustration", text: "this keeps happening over and over" },
    { category: "frustration", text: "why does this always break" },
    { category: "ownership", text: "this belongs to me" },
    { category: "ownership", text: "I own this repository" },
    { category: "ownership", text: "this is my repo" },
  ];

  this.intentTemplates = [];
  for (const i of intents) {
    const embedding = await this.embed(i.text);
    this.intentTemplates.push({ ...i, embedding });
  }
  return this.intentTemplates;
}
```

**Step 4: Run test to verify it passes**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run smoke-test`
Expected: PASS — all tests including [29]. Note: the "wholesale harmony is my app" test may require threshold tuning. If it fails at 0.6, check the actual similarity score and adjust the test threshold accordingly. The template "that's my app" should be close enough semantically.

**Step 5: Commit**

```bash
cd /home/hyperlynq/projects/Coding/claude-context-tool
git add src/storage/embedder.ts scripts/smoke-test.ts
git commit -m "feat: add intent templates for declaration/identity/preference/frustration"
```

---

### Task 3: Add consolidation to maintenance

**Files:**
- Modify: `src/storage/maintenance.ts` (add consolidation step)
- Modify: `src/storage/sqlite.ts` (add `updateEntryContent()` and `mergeTagsInto()` helpers if needed)
- Test: `scripts/smoke-test.ts`

**Step 1: Write the failing test**

Add after test section [29]:

```typescript
// -------------------------------------------------------
// 30. Consolidation in maintenance
// -------------------------------------------------------
console.log("\n[30] Consolidation in maintenance");

index.clearAll();

// Insert 3 near-identical issue entries, backdate them to 5 days ago
const consolidationContent = [
  "Authentication fails when token has special characters in payload",
  "Auth token with special chars causes authentication failure",
  "Token authentication broken when payload contains special characters",
];

const consolidationEmbedding = await embedder.embed("authentication token special characters failure");
const consolidationIds: string[] = [];

for (const content of consolidationContent) {
  const entry = makeEntry({ type: "issue", content });
  const rowid = index.insert(entry);
  index.insertVec(rowid, consolidationEmbedding);
  consolidationIds.push(entry.id);
}

// Backdate all to 5 days ago (must be > 3 days old)
const rawDbCons = new DatabaseSync(DB_PATH);
for (const id of consolidationIds) {
  rawDbCons.exec(`UPDATE entries SET date = date('now', '-5 days') WHERE id = '${id}'`);
}
rawDbCons.close();

// Give one entry higher access count (should be the survivor)
index.touchEntry(consolidationIds[0]);
index.touchEntry(consolidationIds[0]);
index.touchEntry(consolidationIds[0]);

const { runMaintenance } = await import("../src/storage/maintenance.js");
const maintReport = runMaintenance(index);

assert(
  maintReport.consolidated !== undefined && maintReport.consolidated >= 1,
  `Maintenance consolidated ${maintReport.consolidated} group(s)`
);

// Check: survivor still exists, others archived
const afterConsolidation = index.list({ includeArchived: false });
const survivors = afterConsolidation.filter(e => consolidationIds.includes(e.id));
assert(survivors.length === 1, `1 survivor after consolidation (got ${survivors.length})`);
assert(survivors[0].id === consolidationIds[0], `Survivor is the highest-access entry`);
assert(survivors[0].content.includes("[Consolidated from"), `Survivor has consolidation note`);

// Archived entries should be recoverable
const allAfter = index.list({ includeArchived: true });
const archived = allAfter.filter(e => consolidationIds.includes(e.id) && e.archived);
assert(archived.length === 2, `2 entries archived (got ${archived.length})`);
```

**Step 2: Run test to verify it fails**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run smoke-test`
Expected: FAIL — `maintReport.consolidated` is undefined

**Step 3: Write minimal implementation**

First, add helpers to `src/storage/sqlite.ts`:

```typescript
/** Update an entry's content (for consolidation) */
updateEntryContent(id: string, newContent: string): boolean {
  const result = this.db.prepare(
    "UPDATE entries SET content = ? WHERE id = ?"
  ).run(newContent, id);
  // Also update FTS
  if (result.changes > 0) {
    this.db.prepare("DELETE FROM entries_fts WHERE rowid = (SELECT rowid FROM entries WHERE id = ?)").run(id);
    this.db.prepare("INSERT INTO entries_fts(rowid, content, tags) SELECT rowid, content, tags FROM entries WHERE id = ?").run(id);
  }
  return result.changes > 0;
}

/** Merge tags from source entries into a target entry */
mergeTagsInto(targetId: string, sourceIds: string[]): void {
  const targetRow = this.db.prepare("SELECT tags FROM entries WHERE id = ?").get(targetId) as { tags: string } | undefined;
  if (!targetRow) return;

  const allTags = new Set<string>(JSON.parse(targetRow.tags) as string[]);
  for (const srcId of sourceIds) {
    const srcRow = this.db.prepare("SELECT tags FROM entries WHERE id = ?").get(srcId) as { tags: string } | undefined;
    if (srcRow) {
      for (const tag of JSON.parse(srcRow.tags) as string[]) {
        allTags.add(tag);
      }
    }
  }

  this.db.prepare("UPDATE entries SET tags = ? WHERE id = ?").run(JSON.stringify([...allTags]), targetId);
}
```

Then update `src/storage/maintenance.ts`:

```typescript
import { ContextIndex } from "./sqlite.js";

export interface MaintenanceReport {
  decayed: number;
  demoted: number;
  promotedStable: number;
  promotedFrequent: number;
  consolidated: number;
}

export function runMaintenance(index: ContextIndex): MaintenanceReport {
  const decayed = index.decayEphemeral();
  const demoted = index.demoteIdle();
  const promotedStable = index.promoteStable();
  const promotedFrequent = index.promoteFrequent();
  const consolidated = consolidate(index);
  return { decayed, demoted, promotedStable, promotedFrequent, consolidated };
}

function consolidate(index: ContextIndex): number {
  const groups = index.findConsolidationCandidates(0.75);
  if (groups.length === 0) return 0;

  let consolidated = 0;

  for (const group of groups) {
    // Filter to entries older than 3 days
    const now = Date.now();
    const threeDaysMs = 3 * 24 * 60 * 60 * 1000;
    const eligible = group.entries.filter(e => {
      const entryDate = new Date(e.date).getTime();
      return (now - entryDate) > threeDaysMs;
    });

    if (eligible.length < 3) continue; // Need 3+ to consolidate

    // Skip rule and reference types
    if (eligible.some(e => e.type === "rule" || e.type === "reference")) continue;

    // Find survivor: highest access count
    eligible.sort((a, b) => (b.accessCount ?? 0) - (a.accessCount ?? 0));
    const survivor = eligible[0];
    const others = eligible.slice(1);

    // Merge tags from others into survivor
    index.mergeTagsInto(survivor.id, others.map(e => e.id));

    // Update survivor content with consolidation note
    const updatedContent = `${survivor.content}\n[Consolidated from ${eligible.length} entries]`;
    index.updateEntryContent(survivor.id, updatedContent);

    // Promote survivor if ephemeral
    if (survivor.tier === "ephemeral") {
      index.changeTier(survivor.id, "working");
    }

    // Archive others
    index.archiveEntries(others.map(e => e.id));

    consolidated++;
  }

  return consolidated;
}
```

Also add `changeTier()` to `src/storage/sqlite.ts` if not already present:

```typescript
/** Change tier for an entry */
changeTier(id: string, tier: string): boolean {
  const result = this.db.prepare(
    "UPDATE entries SET tier = ? WHERE id = ?"
  ).run(tier, id);
  return result.changes > 0;
}
```

**Step 4: Run test to verify it passes**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run smoke-test`
Expected: PASS — all tests including [30]

**Step 5: Commit**

```bash
cd /home/hyperlynq/projects/Coding/claude-context-tool
git add src/storage/sqlite.ts src/storage/maintenance.ts scripts/smoke-test.ts
git commit -m "feat: wire up consolidation engine in maintenance"
```

---

### Task 4: Upgrade stop hook — intent classification + access bumps

**Files:**
- Modify: `src/hooks/stop.ts`

**Step 1: Add handoff access bumps**

After the handoff entry is created (line ~213), add access bumps for contributing entries:

```typescript
// Bump access for entries that contributed to handoff learnings
for (const insight of todayInsights) {
  index.touchEntry(insight.id);
}

// Also bump corrections that fed into pending rules
for (const entry of todayEntries.filter(e => e.tags.includes("correction"))) {
  index.touchEntry(entry.id);
}
```

**Step 2: Add intent classification after correction detection**

After the correction detection block (after line ~205), add:

```typescript
// Intent classification — autonomous capture of declarations, preferences, etc.
try {
  const intentTemplates = await embedder.getIntentTemplates();
  const autoCaptures: Array<{ content: string; category: string; similarity: number }> = [];

  for (const entry of nonInsightEntries.slice(0, 20)) {
    const match = await embedder.classifySentence(entry.content, intentTemplates, 0.6);
    if (match) {
      // Deduplicate: check if similar entry already exists as reference or rule
      const existingRefs = index.list({ days: 30 })
        .filter(e => e.type === "reference" || e.type === "rule");

      let isDuplicate = false;
      const entryEmb = await embedder.embed(entry.content);
      for (const ref of existingRefs.slice(0, 30)) {
        const refEmb = await embedder.embed(ref.content);
        let dot = 0;
        for (let i = 0; i < entryEmb.length; i++) {
          dot += entryEmb[i] * refEmb[i];
        }
        if (dot >= 0.8) {
          isDuplicate = true;
          break;
        }
      }

      if (!isDuplicate) {
        autoCaptures.push({ content: entry.content, ...match });
      }
    }
  }

  // Save auto-captured intents
  const capturedCounts = new Map<string, number>();
  for (const capture of autoCaptures.slice(0, 5)) {
    const type = (capture.category === "frustration") ? "issue" : "reference";
    const tier = (capture.category === "frustration") ? "working" : "longterm";

    const captureEntry = appendEntry(
      capture.content,
      type,
      [`auto-captured`, `intent:${capture.category}`]
    );
    captureEntry.tier = tier;
    const captureRowid = enrichInsert(captureEntry);
    const captureEmb = await embedder.embed(capture.content);
    index.insertVec(captureRowid, captureEmb);

    capturedCounts.set(capture.category, (capturedCounts.get(capture.category) ?? 0) + 1);
  }

  if (capturedCounts.size > 0) {
    const parts = Array.from(capturedCounts.entries()).map(([cat, count]) => `${count} ${cat}(s)`);
    contentParts.push(`Auto-captured: ${parts.join(", ")}`);
  }
} catch {
  // Don't fail the handoff if intent classification errors
}
```

**Step 3: Build and verify**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build`
Expected: No TypeScript errors

**Step 4: Commit**

```bash
cd /home/hyperlynq/projects/Coding/claude-context-tool
git add src/hooks/stop.ts
git commit -m "feat: stop hook intent classification + handoff access bumps"
```

---

### Task 5: Upgrade session-start — predicted focus

**Files:**
- Modify: `src/hooks/session-start.ts`

**Step 1: Replace sections 5 (Related context + co-change suggestions) with Predicted Focus**

Replace the entire `// --- SECTION 5: Related context from git activity ---` block (lines 177-218) with:

```typescript
// --- SECTION 5: Predicted focus ---
const budgetForFocus: string[] = [];
const cwd = process.cwd();
if (isGitRepo(cwd)) {
  try {
    const { getCurrentBranch } = await import("../storage/git.js");
    const branch = getCurrentBranch(cwd);
    const recentFiles = getRecentlyChangedFiles(cwd);

    // Build focus query from branch + files + last handoff
    const queryParts: string[] = [];
    if (branch && branch !== "main" && branch !== "master") {
      // Branch name often contains feature context: feature/auth-rework -> auth rework
      queryParts.push(branch.replace(/[\/\-_]/g, " "));
    }
    if (recentFiles.length > 0) {
      queryParts.push(recentFiles.slice(0, 5).join(" "));
    }
    // Include last handoff learnings for continuity
    const handoffs = index.list({ days: 7, type: "handoff" }).slice(0, 1);
    if (handoffs.length > 0) {
      const handoffContent = handoffs[0].content.slice(0, 200);
      queryParts.push(handoffContent);
    }

    if (queryParts.length > 0) {
      const focusQuery = queryParts.join(" ");
      const focusResults = index.search(focusQuery, { limit: 3 })
        .filter(e => e.type !== "handoff" && e.type !== "git_commit");

      if (focusResults.length > 0) {
        const fileCount = recentFiles.length;
        const branchStr = branch ? `Branch: ${branch}` : "No branch";
        const filesStr = fileCount > 0 ? ` | ${fileCount} uncommitted file${fileCount === 1 ? "" : "s"}` : "";

        budgetForFocus.push("## Predicted focus");
        budgetForFocus.push(`${branchStr}${filesStr}`);
        for (const r of focusResults) {
          const ago = Math.floor((Date.now() - new Date(r.date).getTime()) / (1000 * 60 * 60 * 24));
          budgetForFocus.push(`- [${ago}d ago] ${r.type}: ${r.content.slice(0, 120)}`);
        }
        budgetForFocus.push("");
      }
    }

    // Co-change suggestions (keep but fold into focus section)
    if (currentProject && recentFiles.length > 0) {
      const suggestions: string[] = [];
      for (const file of recentFiles.slice(0, 5)) {
        const cochanges = index.getCoChanges(currentProject, file, 3)
          .filter(c => c.count >= 3 && !recentFiles.includes(c.file));
        if (cochanges.length > 0) {
          const pairs = cochanges.map(c => `${c.file} (${c.count}x)`).join(", ");
          suggestions.push(`- ${file} → usually also changes: ${pairs}`);
        }
      }
      if (suggestions.length > 0) {
        if (budgetForFocus.length === 0) {
          budgetForFocus.push("## Predicted focus");
        }
        budgetForFocus.push(...suggestions);
        budgetForFocus.push("");
      }
    }
  } catch {
    // Don't block session start
  }
}
```

Then update the sections assembly (line ~256) to use `budgetForFocus` instead of separate `budgetForRelated` and `budgetForCochanges`:

```typescript
const sections = [budgetForPending, budgetForContext, budgetForHandoff, budgetForPatterns, budgetForFocus, budgetForCrossProject, budgetForMaint];
```

Remove the now-unused `budgetForRelated` and `budgetForCochanges` variables.

**Step 2: Build and verify**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build`
Expected: No TypeScript errors

**Step 3: Commit**

```bash
cd /home/hyperlynq/projects/Coding/claude-context-tool
git add src/hooks/session-start.ts
git commit -m "feat: session-start predicted focus from branch + diff + handoff"
```

---

### Task 6: Update session-start maintenance reporting for consolidation

**Files:**
- Modify: `src/hooks/session-start.ts` (maintenance summary section)

**Step 1: Update maintenance summary**

In the maintenance summary section (~line 244), add consolidation reporting:

```typescript
const maintTotal = maintenance.decayed + maintenance.demoted + maintenance.promotedStable + maintenance.promotedFrequent + maintenance.consolidated;
if (maintTotal > 0) {
  const parts: string[] = [];
  if (maintenance.decayed > 0) parts.push(`${maintenance.decayed} archived`);
  if (maintenance.demoted > 0) parts.push(`${maintenance.demoted} demoted`);
  if (maintenance.promotedStable > 0) parts.push(`${maintenance.promotedStable} promoted`);
  if (maintenance.promotedFrequent > 0) parts.push(`${maintenance.promotedFrequent} promoted`);
  if (maintenance.consolidated > 0) parts.push(`${maintenance.consolidated} consolidated`);
  budgetForMaint.push(`_Maintenance: ${parts.join(", ")}._`);
}
```

**Step 2: Build and verify**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build`
Expected: No TypeScript errors

**Step 3: Commit**

```bash
cd /home/hyperlynq/projects/Coding/claude-context-tool
git add src/hooks/session-start.ts
git commit -m "feat: session-start reports consolidation counts"
```

---

### Task 7: Update smoke test version check + run full test suite

**Files:**
- Modify: `scripts/smoke-test.ts` (version check)
- Modify: `package.json` (version bump)

**Step 1: Bump version**

In `package.json`, change `"version": "0.6.0"` to `"version": "0.7.0"`.

**Step 2: Update version check in smoke test**

In `scripts/smoke-test.ts`, section [27], change:

```typescript
assert(pkgFinal.version === "0.7.0", `Version is 0.7.0 (got ${pkgFinal.version})`);
```

**Step 3: Run full test suite**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run smoke-test`
Expected: ALL tests pass, 0 failed

**Step 4: Commit**

```bash
cd /home/hyperlynq/projects/Coding/claude-context-tool
git add package.json scripts/smoke-test.ts
git commit -m "chore: bump version to 0.7.0 — Proactive Intelligence"
```

---

### Task 8: Update README + push

**Files:**
- Modify: `README.md`

**Step 1: Update README with v0.7.0 features**

Read the current README, then update it to document:
- Intent classification (auto-capture of declarations, preferences, identities)
- Predicted focus in session-start
- Consolidation engine
- Handoff access bumps
- New version number

**Step 2: Commit and push**

```bash
cd /home/hyperlynq/projects/Coding/claude-context-tool
git add README.md
git commit -m "docs: update README for v0.7.0 proactive intelligence"
git push origin main
```

---

## Task Summary

| Task | Description | Files | Effort |
|------|-------------|-------|--------|
| 1 | `touchEntry()` in sqlite.ts | sqlite.ts, smoke-test.ts | Tiny |
| 2 | Intent templates in embedder.ts | embedder.ts, smoke-test.ts | Small |
| 3 | Consolidation in maintenance | maintenance.ts, sqlite.ts, smoke-test.ts | Medium |
| 4 | Stop hook: intent classification + access bumps | stop.ts | Medium |
| 5 | Session-start: predicted focus | session-start.ts | Medium |
| 6 | Session-start: consolidation reporting | session-start.ts | Tiny |
| 7 | Version bump + full test run | package.json, smoke-test.ts | Tiny |
| 8 | README update + push | README.md | Small |
