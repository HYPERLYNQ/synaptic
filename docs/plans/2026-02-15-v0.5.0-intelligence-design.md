# Synaptic v0.5.0 — Intelligence Layer Design

**Date:** 2026-02-15
**Version:** 0.4.0 → 0.5.0
**Codename:** Intelligence Layer

## Overview

Seven features that push Synaptic from "persistent memory" to "intelligent memory." The system learns from usage patterns, detects corrections, shares context across agents and projects, predicts what you'll need, and understands codebase relationships — all local, zero-cloud.

## Implementation Strategy: Layered Rollout

### Wave 1 — Data Foundation
Schema changes, scoring upgrades, co-change index. No new tools except `context_session` and `context_cochanges`. Touches DB + existing code.

### Wave 2 — Smarter Hooks
Enhanced session-start (predictive injection), enhanced stop hook (distillation + auto-rule detection). Behavior changes visible to the user.

### Wave 3 — Cross-Cutting Intelligence
Co-change suggestions in injection, auto-rule approval flow, cross-project surfacing. The "wow" features.

---

## Feature 1: Confidence Scoring

### Problem
`access_count` and `last_accessed` exist but only drive ephemeral→working promotion at 3+ accesses. Unused entries persist as long as frequently-used ones.

### Design

**Search ranking change:**

Current: `score = RRF_score × temporal_decay × tier_weight`

New: `score = RRF_score × temporal_decay × tier_weight × confidence_boost`

Confidence boost values:
- 0 accesses → `0.7` (penalty for never-used)
- 1-2 accesses → `1.0` (neutral)
- 3-5 accesses → `1.2` (mild boost)
- 6+ accesses → `1.4` (strong boost)

**Decay acceleration:**

Ephemeral tier:
- 0 accesses → archive after 3 days (was 7)
- 1-2 accesses → archive after 7 days (unchanged)
- 3+ accesses → archive after 14 days (extended)

Working tier idle demotion:
- 0 accesses → demote after 15 days (was 30)
- 1-2 accesses → demote after 30 days (unchanged)
- 3+ accesses → demote after 60 days (extended)

**Pinned entries** remain immune from all decay regardless of access count.

### Wave
Wave 1.

### Files Modified
- `src/storage/sqlite.ts` — update scoring in hybrid search
- `src/storage/maintenance.ts` — access-aware decay/demotion windows

---

## Feature 2: Cross-Project Intelligence

### Problem
All entries stored in one DB with no project awareness. Can't prioritize same-project results or surface insights from other projects.

### Design

**New column:** `project TEXT DEFAULT NULL` on `entries` table.

**Auto-detection** (in order of preference):
1. Git remote name: parse `origin` URL → extract repo name
2. Folder name: last component of cwd path
3. `NULL` if neither works (entry is "global")

Project is detected once at server startup and cached for the session.

**Search ranking:** Same-project results get `1.5x` multiplier. Other projects and global entries get `1.0x`.

**Session-start injection:** After normal context, if high-confidence matches exist from other projects, add:

```
## From other projects
- [field-bridge] Solved WSL native module issue by using wsl.exe as command
```

Threshold: only surface cross-project matches with score > 0.7 (after all other scoring).

**No backfill.** Existing entries stay `project = NULL` (global). New entries get tagged automatically.

### Wave
Wave 1 (schema + auto-detection + search boost). Wave 3 (cross-project surfacing in injection).

### Files Modified
- `src/storage/sqlite.ts` — new column, migration, project-aware queries
- `src/storage/paths.ts` or new `src/storage/project.ts` — project detection logic
- `src/tools/context-save.ts` — auto-tag project on save
- `src/tools/context-search.ts` — project boost in scoring
- `src/hooks/session-start.ts` — cross-project section (Wave 3)

---

## Feature 3: Auto-Generated Rules from Corrections

### Problem
Users repeatedly correct Claude on the same things. These corrections should become enforced rules, not forgotten context.

### Design

**Two-layer detection:**

**Layer 1 — Real-time (during session):**
A persistent rule instructs Claude to call `context_save` with type `insight` and a `correction:true` tag whenever it detects a directive from the user (always/never/stop/from now on). Claude has full conversational context and understands intent — this is the primary detection mechanism.

**Layer 2 — Safety net (stop hook):**
The stop hook uses the embedding model for semantic sentence classification:
1. Split conversation into sentences
2. Compare each sentence embedding against pre-computed directive templates:
   - "always do X from now on"
   - "never do Y again"
   - "stop doing Z"
   - "please remember to..."
3. Sentences with cosine similarity > 0.75 to a template are flagged
4. Save flagged corrections as `pending_rule` entries (new tag, not enforced yet)

**Pending rule flow:**
- Stored as entries with tag `pending_rule` + proposed label + proposed content
- Session-start hook surfaces pending rules:
  ```
  ## Pending rules (approve or dismiss)
  - "always-use-bun": Always use bun instead of npm
  ```
- Claude asks user to confirm. On accept → `context_save_rule`. On dismiss → archive the entry.

**Conflict detection:**
When a new correction contradicts an existing rule (detected via semantic similarity between correction and existing rule content):
- Flag the conflict in session-start
- Present options: update rule / keep original / dismiss
- Never silently override an enforced rule

### Wave
Wave 2 (stop hook detection, pending rule storage). Wave 3 (conflict detection, approval flow in session-start).

### Files Modified
- `src/hooks/stop.ts` — embedder-based correction detection
- `src/hooks/session-start.ts` — surface pending rules, conflict detection
- `src/storage/embedder.ts` — pre-computed directive template embeddings

### New Rule (installed on v0.5.0 setup)
```
label: "auto-distill"
content: "When a significant decision is made, a problem is solved, a correction is given, or something surprising is discovered, save it as an insight to Synaptic immediately using context_save. Tag corrections with 'correction'. Don't wait for session end."
```

---

## Feature 4: Conversation Distillation

### Problem
Stop hook saves metadata handoffs ("22 entries, 4 progress"). No substance.

### Design

**Replaces current handoff format.** Same `handoff` type, richer content.

**New format:**
```
Activity: 14 entries across field-bridge, synaptic.
Learnings:
- VS Code reads MCP servers from .mcp.json in project root, not settings.json
- Windows node can't load WSL native modules — use wsl.exe as command
- Confidence scoring: access_count already exists, needs to influence ranking
Corrections detected: 1 pending rule proposal saved.
```

**Extraction approach (two layers):**

**Layer 1 — Real-time saves (primary):**
The `auto-distill` rule (from Feature 3) instructs Claude to save insights as they happen. The stop hook collects these recent saves and formats them into the "Learnings" section.

**Layer 2 — Embedder safety net:**
The stop hook also scans remaining conversation text through semantic classification:
1. Split into sentences
2. Embed and compare against category templates:
   - Decision templates: "we decided to...", "let's go with...", "option A is better"
   - Solution templates: "the fix was...", "this worked because...", "the problem was..."
   - Discovery templates: "turns out...", "found out...", "the reason is..."
3. Top matches (similarity > 0.7) added to learnings if not already captured by Layer 1
4. Cap at 5 bullet points total, deduped

**Activity line:** Entry count + project names from today's entries. One line.

### Wave
Wave 2.

### Files Modified
- `src/hooks/stop.ts` — new handoff format, embedder-based extraction, collect real-time saves
- `src/storage/embedder.ts` — category template embeddings

---

## Feature 5: Predictive Context Injection

### Problem
Session-start injection is reactive — "here's what happened recently." Should be proactive — "here's what you'll probably need."

### Design

**Mode: Medium** (default, no toggle). Adds project + git awareness to existing injection.

**New steps in session-start hook (after normal injection):**

**Step 1 — Project detection:**
Detect current project (same logic as Feature 2). Filter recent context to prioritize same-project entries.

**Step 2 — Git activity analysis:**
```bash
git diff --name-only HEAD~3   # last 3 commits
git diff --name-only           # uncommitted changes
```
Extract list of recently touched files.

**Step 3 — Co-change suggestions:**
Look up touched files in `file_pairs` table. Surface co-change relationships:
```
## Predictive context
Recently touched files:
- src/hooks/stop.ts → usually also changes: src/server.ts (8x), src/storage/sqlite.ts (5x)
```

Only show pairs with co_change_count >= 3 (filter noise).

**Step 4 — Related past context:**
Use recently touched file names as a search query against entries. Surface related decisions/issues/insights:
```
## Related context
- [2 days ago] Fixed embedder cold start by pre-warming on startup
```

**Token budget:** Increase from 3200 → 4000 chars (~1000 tokens) to accommodate new sections.

### Wave
Wave 2 (project filtering, git analysis, related context). Wave 3 (co-change suggestions, requires Feature 7).

### Files Modified
- `src/hooks/session-start.ts` — project filtering, git analysis, new injection sections
- `src/storage/git.ts` — extract recently changed files (new helper)

---

## Feature 6: Agent Context Sharing (Session Bus)

### Problem
Subagents are isolated. They can't see what other agents discovered or what decisions the main agent made.

### Design

**No new table.** Agents write to the existing `entries` table.

**New columns on `entries`:**
```sql
ALTER TABLE entries ADD COLUMN session_id TEXT DEFAULT NULL;
ALTER TABLE entries ADD COLUMN agent_id TEXT DEFAULT NULL;
```

**Session ID detection:**
- Check `CLAUDE_SESSION_ID` env var (if Claude Code exposes it)
- Fallback: generate hash from `process.pid + process.ppid + start time`
- Cached for server lifetime

**Agent ID:**
- New optional parameter on `context_save`: `agent_id`
- Defaults to `"main"` if not provided
- Subagents can pass their identifier when saving

**New tool — `context_session`:**
```
context_session(session_id?: string, type?: string)
```
- Returns all entries from current session (or specified session)
- Optional type filter
- Sorted chronologically
- No embeddings needed — indexed column, simple SELECT
- Fast path for agent coordination

**New index:**
```sql
CREATE INDEX idx_entries_session ON entries(session_id);
```

**Usage pattern:**
1. Main agent saves decisions via `context_save` (auto-tagged with session_id)
2. Spawns subagents with instruction: "check context_session for decisions made so far"
3. Subagents read session context, work accordingly, save their findings
4. Main agent calls `context_session` to collect all findings

### Wave
Wave 1 (schema + tool). Immediately useful once columns exist.

### Files Modified
- `src/storage/sqlite.ts` — new columns, migration, session query method
- `src/tools/context-save.ts` — auto-tag session_id, accept optional agent_id
- `src/tools/context-session.ts` — new tool
- `src/server.ts` — register new tool

---

## Feature 7: Codebase-Aware Memory (Co-Change Index)

### Problem
No understanding of file relationships. Can't predict that modifying file A usually requires changes to file B.

### Design

**New table:**
```sql
CREATE TABLE file_pairs (
  project TEXT NOT NULL,
  file_a TEXT NOT NULL,
  file_b TEXT NOT NULL,
  co_change_count INTEGER DEFAULT 1,
  last_seen TEXT NOT NULL,
  PRIMARY KEY (project, file_a, file_b)
);
CREATE INDEX idx_file_pairs_lookup ON file_pairs(project, file_a);
```

**Built during git indexing.** The `context_git_index` tool already scans commits. Piggyback on it:

For each commit, extract changed files. For every pair:
```
Commit: "fix auth + update tests"
Files: src/auth.ts, src/auth.test.ts, src/server.ts

Pairs:
  (project, src/auth.ts, src/auth.test.ts) → +1
  (project, src/auth.ts, src/server.ts) → +1
  (project, src/auth.test.ts, src/server.ts) → +1
```

**Limits:**
- Skip commits with 20+ files (merge commits, bulk renames — too noisy)
- Only surface pairs with co_change_count >= 2
- Cap at 500 pairs per project (prune lowest counts if exceeded)

**Refresh:** Incremental on each `context_git_index` call. Only processes new commits (dedup by SHA already exists).

**New tool — `context_cochanges`:**
```
context_cochanges(file: string, project?: string, limit?: number)
```

Returns files that frequently co-change with the given file:
```json
{
  "file": "src/hooks/stop.ts",
  "project": "synaptic",
  "cochanges": [
    { "file": "src/server.ts", "count": 8, "last_seen": "2026-02-15" },
    { "file": "src/storage/sqlite.ts", "count": 5, "last_seen": "2026-02-14" }
  ]
}
```

**Surfaced in session-start** (Feature 5, Step 3) for recently touched files.

### Wave
Wave 1 (table + indexing + tool). Wave 3 (surfacing in session-start via Feature 5).

### Files Modified
- `src/storage/sqlite.ts` — new table, migration, co-change queries, pair generation
- `src/tools/context-git-index.ts` — generate file pairs during commit indexing
- `src/tools/context-cochanges.ts` — new tool
- `src/server.ts` — register new tool

---

## Schema Migration Summary

### New Columns on `entries`
```sql
ALTER TABLE entries ADD COLUMN project TEXT DEFAULT NULL;
ALTER TABLE entries ADD COLUMN session_id TEXT DEFAULT NULL;
ALTER TABLE entries ADD COLUMN agent_id TEXT DEFAULT NULL;
```

### New Indexes
```sql
CREATE INDEX idx_entries_project ON entries(project);
CREATE INDEX idx_entries_session ON entries(session_id);
```

### New Table
```sql
CREATE TABLE file_pairs (
  project TEXT NOT NULL,
  file_a TEXT NOT NULL,
  file_b TEXT NOT NULL,
  co_change_count INTEGER DEFAULT 1,
  last_seen TEXT NOT NULL,
  PRIMARY KEY (project, file_a, file_b)
);
CREATE INDEX idx_file_pairs_lookup ON file_pairs(project, file_a);
```

### Migration Strategy
Run ALTER TABLE statements on startup if columns don't exist (same pattern as v0.3.0→v0.4.0 migrations). Check with `PRAGMA table_info(entries)`.

---

## New Tools Summary

| Tool | Parameters | Purpose |
|------|-----------|---------|
| `context_session` | `session_id?`, `type?` | List entries from current/specified session |
| `context_cochanges` | `file`, `project?`, `limit?` | Get files that frequently co-change with given file |

Total tools: 10 existing + 2 new = **12 tools**.

## New Rule (Auto-Installed)

```
label: "auto-distill"
content: "When a significant decision is made, a problem is solved, a correction
is given, or something surprising is discovered, save it as an insight to Synaptic
immediately using context_save. Tag corrections with 'correction'. Don't wait for
session end."
```

---

## Token Budget Update

Session-start injection budget: 3200 → **4000 chars** (~1000 tokens).

Injection priority (updated):
1. Rules (never truncated)
2. Pending rules for approval (Wave 3)
3. Recent context (project-filtered, last 3 days)
4. Predictive context (co-changes + related past context)
5. Cross-project insights (high-confidence only)
6. Recent handoff (single, with learnings)
7. Recurring patterns
8. Maintenance summary (only if something changed)
9. Entry count footer

Sections dropped bottom-up if over budget.

---

## Wave Breakdown

### Wave 1 — Data Foundation
- [ ] Schema migration (3 columns + file_pairs table + indexes)
- [ ] Project auto-detection (git remote / folder name)
- [ ] Auto-tag project + session_id + agent_id on save
- [ ] Confidence boost in search ranking
- [ ] Access-aware decay windows in maintenance
- [ ] Co-change pair generation during git indexing
- [ ] `context_session` tool
- [ ] `context_cochanges` tool
- [ ] Smoke tests for new features

### Wave 2 — Smarter Hooks
- [ ] Session-start: project-aware filtering of injected context
- [ ] Session-start: git activity analysis + related past context
- [ ] Stop hook: new handoff format (activity + learnings)
- [ ] Stop hook: embedder-based sentence classification for missed learnings
- [ ] Stop hook: correction detection → pending rule entries
- [ ] Pre-computed template embeddings for classification
- [ ] Install `auto-distill` rule
- [ ] Smoke tests for hook changes

### Wave 3 — Intelligence
- [ ] Session-start: co-change suggestions for recently touched files
- [ ] Session-start: cross-project insight surfacing
- [ ] Session-start: pending rule approval prompt
- [ ] Conflict detection between corrections and existing rules
- [ ] Smoke tests for intelligence features

---

## Non-Goals

- No cloud API calls. Everything stays local.
- No AST parsing. Co-change index from git is sufficient.
- No backfill of project tags on existing entries.
- No separate scratchpad table for agents.
- No toggle for predictive injection levels (medium is the default).
- No new entry types. Reuse existing types with tags for differentiation.
