# Synaptic v0.6.0 — Autonomous Intelligence Design

**Date:** 2026-02-16
**Version:** 0.5.0 → 0.6.0
**Codename:** Autonomous Intelligence

## What This Version Does

Synaptic v0.5.0 gave Claude persistent memory. v0.6.0 makes that memory *active* — it watches your project in real time, guards your commits, learns from failures, understands your codebase's personality, and tracks decisions through to their outcomes.

Six features, two phases:

**Phase 1 — Infrastructure:**
1. **Installer CLI** — `npx synaptic init` sets up everything in one command
2. **Watch Mode** — Real-time git event observer running inside the MCP server
3. **Pre-Commit Guardian** — Git hook that captures failures into memory

**Phase 2 — Intelligence:**
4. **Failure Memory** — Tracks recurring failures and their resolutions
5. **Codebase DNA** — Discovers your project's patterns from git history
6. **Decision Chains** — Links decisions to their outcomes over time

---

## How Synaptic Works (Background)

For readers new to the project: Synaptic is a local MCP (Model Context Protocol) server that gives Claude persistent memory across sessions. It stores context entries in SQLite with full-text search (FTS5) and vector similarity search (sqlite-vec). Three hooks run automatically:

- **SessionStart** — Injects recent context, rules, and predictions when Claude starts
- **PreCompact** — Preserves context before Claude's conversation is compressed
- **Stop** — Saves a handoff summary when Claude finishes

Everything runs locally. No cloud, no API keys, no data leaves your machine.

**Current state (v0.5.0):** 12 MCP tools, 3 hooks, project-aware search with confidence scoring, co-change index, agent session sharing. 96 tests.

---

## Feature 1: Installer CLI (`npx synaptic init`)

### The Problem

Setting up Synaptic requires manually editing `~/.claude/settings.json` to add the MCP server config and three hooks. On WSL, you need to edit the Windows-side config with `wsl.exe` wrapper commands. This is fiddly and error-prone.

### The Solution

A single CLI command that detects your environment and configures everything:

```bash
npx synaptic init          # Full setup: MCP + hooks + git hook + project dir
npx synaptic init --global # MCP + hooks only (no git-specific setup)
```

### How It Works

**New file: `src/cli.ts`** — Entry point with `#!/usr/bin/env node` shebang.

**Environment detection:**
The installer figures out where it's running:
- **WSL** — Detected via `/proc/version` containing "microsoft". Writes to Windows-side `~/.claude/settings.json` using the Windows user profile path.
- **Native Linux/Mac** — Writes directly to `~/.claude/settings.json`.

**What `init` sets up:**

1. **MCP server config** — Adds `synaptic` server entry to settings.json. On WSL, uses `wsl.exe` as the command wrapper. On native, uses `node` directly.

2. **Claude Code hooks** — Adds SessionStart, PreCompact, and Stop hook entries. Same WSL/native path logic.

3. **Git pre-commit hook** — Writes `.git/hooks/pre-commit` script that calls Synaptic's guardian (Feature 3). Only if `.git/` exists and `--global` wasn't passed.

4. **Project directory** — Creates `.synaptic/` in the project root with a `config.json` for future extensibility (e.g., custom test commands, ignore patterns).

**package.json change:**
```json
{
  "bin": {
    "synaptic": "build/src/cli.js"
  }
}
```

This makes `npx synaptic init` work — npm resolves the package and runs the CLI entry point.

### Files

- Create: `src/cli.ts` — CLI entry point, command parser, environment detection
- Create: `src/cli/init.ts` — The init command logic
- Modify: `package.json` — Add `bin` field

---

## Feature 2: Watch Mode — Git Event Observer

### The Problem

Synaptic only learns about git activity when the session-start hook runs (once per session) or when Claude manually calls `context_git_index`. If you switch branches, make commits, or rebase mid-session, Synaptic doesn't know until the next session.

### The Solution

A file watcher that runs inside the MCP server process. It observes `.git/` for meaningful events and auto-indexes them.

### How It Works

**New file: `src/storage/watcher.ts`**

Uses Node.js built-in `fs.watch()` to observe:
- `.git/HEAD` — Changes when you switch branches
- `.git/refs/heads/` — Changes when new commits land
- `.git/COMMIT_EDITMSG` — Written when a commit is being created

**Event handling:**
When a watched file changes:
1. A 2-second debounce timer starts (batches rapid events like rebase)
2. After debounce, runs `contextGitIndex({ days: 1 })` to capture new commits
3. On branch switch (HEAD change), saves a progress entry: "Switched to branch X"

**Lifecycle:**
- Starts when the MCP server starts (called from `createServer()` in `src/server.ts`)
- Stops automatically when the MCP server exits
- If `.git/` doesn't exist (not a git repo), watcher is a silent no-op
- Uses `AbortController` for clean shutdown

**Why inside the MCP server process (not a separate daemon):**
- No extra process to manage or kill
- Shares the existing `ContextIndex` and `Embedder` instances
- Dies when Claude dies — no orphan processes

### Files

- Create: `src/storage/watcher.ts` — File watcher logic
- Modify: `src/server.ts` — Start watcher on server creation

---

## Feature 3: Pre-Commit Guardian

### The Problem

When commits fail tests or lint, that information vanishes. The developer fixes the issue and moves on. But if the same file keeps causing failures, nobody notices the pattern.

### The Solution

A git pre-commit hook that runs your project's test/lint commands. On failure, it captures the error details into Synaptic. On success, it's invisible.

### How It Works

**New file: `src/cli/pre-commit.ts`** — The script that `.git/hooks/pre-commit` calls.

**Step 1 — Detect commands to run:**
Reads `package.json` and looks for these scripts (in order):
1. `lint` (or `eslint`)
2. `typecheck` (or `tsc`, `check`)
3. `test`

Only runs scripts that exist. Stops on first failure.

**Step 2 — Run commands:**
Executes each command via `child_process.execSync`. Captures stdout and stderr.

**Step 3a — On success:**
Exit code 0. Commit proceeds. No Synaptic interaction.

If there were recent failures for the committed files, saves a resolution entry:
```
context_save(type: "progress", content: "Resolved: src/auth.ts now passes tests",
  tags: ["failure-resolved", "file:src/auth.ts", "chain:<original-failure-chain-id>"])
```

**Step 3b — On failure:**
Saves a failure entry:
```
context_save(type: "issue", content: "Pre-commit failure: `npm run test` exited 1\nFiles: src/auth.ts\nError: Expected 3 to equal 4 at auth.test.ts:42",
  tags: ["failure", "pre-commit", "cmd:test", "file:src/auth.ts"])
```

Then exits with code 1 (commit blocked).

**Error output capture:** Last 50 lines of stderr + stdout combined. Enough context for Claude to understand the failure without storing megabytes of test output.

### Files

- Create: `src/cli/pre-commit.ts` — Pre-commit hook logic
- Modify: `src/cli/init.ts` — Install hook during `npx synaptic init`

---

## Feature 4: Failure Memory

### The Problem

Individual failures are captured by the pre-commit guardian (Feature 3). But without connecting them, you can't see that `src/auth.ts` has failed 5 times this week, or that test failures in `storage/` usually mean you forgot to update the migration.

### The Solution

Failure memory is not a separate system — it's the existing pattern detection and session-start injection applied to failure entries. The pre-commit guardian creates entries with consistent tags; the rest happens automatically.

### How It Works

**Pattern detection (already exists):**
The `patterns` table in SQLite tracks recurring entries. When the same file tag (`file:src/auth.ts`) appears in 3+ failure entries, it becomes a recurring pattern.

**Session-start surfacing (already exists):**
The "Recurring Issues" section in session-start injection already shows patterns. Failure patterns show up as:
```
## Recurring Issues
- "pre-commit:src/auth.ts" — 4x failures (last: 02-16)
```

**Failure resolution (new):**
When the pre-commit guardian succeeds and finds recent failures for the same files, it saves a resolution entry with a `chain:<id>` tag linking back to the original failure. This creates a traceable failure → fix → resolution narrative.

**What Claude sees:**
When Claude encounters a failure pattern in session-start injection, it knows:
- Which file keeps failing
- What kind of failures (test, lint, typecheck)
- Whether there's a resolution in the chain
- How recently and how often

### Why This Works Without New Infrastructure

The pre-commit guardian (Feature 3) handles all the data collection. Failure memory is a *behavior* that emerges from existing systems:
- Tags (`failure`, `file:X`, `cmd:Y`) enable filtering
- Pattern detection catches repeat offenders
- Session-start injection surfaces them
- Decision chains (Feature 6) link failures to resolutions

No new tables, no new columns, no new tools.

### Files

- No new files — this feature is the pre-commit guardian + existing pattern system working together
- Modify: `src/hooks/session-start.ts` — Enhanced formatting for failure patterns (minor)

---

## Feature 5: Codebase DNA — Pattern Discovery

### The Problem

Claude starts every session with no understanding of the project's coding patterns, architectural conventions, or structural personality. It has to rediscover these from scratch each time.

### The Solution

A new MCP tool that analyzes git history and produces a "DNA report" — a compact summary of the project's patterns, hotspots, and structure. Saved as a longterm reference entry that Claude can find through search.

### How It Works

**New tool: `context_dna`**

Parameters:
- `commits` (optional, default 100) — How many commits to analyze
- `repo_path` (optional, default cwd) — Path to git repo

**Analysis steps:**

**1. Hotspot detection:**
Count how many commits each file appears in. Files changed in >20% of commits are "hotspots" — they're the core of the project.
```
Hotspots: src/storage/sqlite.ts (45%), src/hooks/session-start.ts (30%)
```

**2. Architectural layers:**
Group files by their top-level directory under `src/`. Report what percentage of changes happen in each layer.
```
Layers: tools/ (35%), storage/ (30%), hooks/ (25%), cli/ (10%)
```

**3. Commit patterns:**
Analyze commit messages for prefixes (feat, fix, chore, etc.), average files per commit, and test-to-source ratio.
```
Patterns: 60% feat, 25% fix, 15% chore. Avg 3.2 files/commit. Test ratio: 0.4
```

**4. Co-change clusters:**
Build on the existing `file_pairs` table. Files that frequently co-change get grouped into named clusters.
```
Clusters: [sqlite.ts + embedder.ts + server.ts], [session-start.ts + stop.ts]
```

**Output:**
Saves a single `reference` entry with `longterm` tier:
```
Codebase DNA (synaptic, 100 commits analyzed):
Hotspots: src/storage/sqlite.ts (45%), src/hooks/session-start.ts (30%)
Layers: tools/ (35%), storage/ (30%), hooks/ (25%), cli/ (10%)
Patterns: 60% feat, 25% fix, 15% chore. Avg 3.2 files/commit.
Clusters: [sqlite.ts + embedder.ts + server.ts], [session-start.ts + stop.ts]
```

**When to run:**
- Manually: `context_dna` tool call
- Automatically: during `npx synaptic init` for first-time project onboarding
- Re-run periodically (monthly) to update as the project evolves

**Why longterm reference:**
DNA entries are `reference` type, which auto-assigns to `longterm` tier. They survive all decay/maintenance cycles and show up in searches when Claude is making architectural decisions.

### Files

- Create: `src/tools/context-dna.ts` — DNA analysis tool
- Modify: `src/server.ts` — Register new tool
- Modify: `src/cli/init.ts` — Auto-run DNA on init

---

## Feature 6: Decision Chains

### The Problem

Decisions are isolated events. When Claude records "Use SQLite instead of LevelDB," there's no way to later connect it to "SQLite WAL mode conflicts with WSL" or "Switched to journal_mode=DELETE." The narrative is lost.

### The Solution

Tag-based chain IDs that link related entries into traceable threads. A new tool lets Claude (or the user) retrieve the full chain.

### How It Works

**Chain ID format:** `chain:<8-char-hex>` tag (e.g., `chain:a1b2c3d4`).

**Creating a chain:**
When Claude saves a significant decision, it includes a new chain tag:
```
context_save(
  type: "decision",
  content: "Use SQLite instead of LevelDB for persistence",
  tags: ["chain:a1b2c3d4", "database"]
)
```

**Adding to a chain:**
Follow-up entries reference the same chain ID:
```
context_save(type: "progress", content: "SQLite migration complete, 96 tests passing",
  tags: ["chain:a1b2c3d4"])

context_save(type: "issue", content: "SQLite WAL mode conflicts with WSL file locking",
  tags: ["chain:a1b2c3d4"])

context_save(type: "decision", content: "Switched to journal_mode=DELETE for WSL compat",
  tags: ["chain:a1b2c3d4"])
```

**New tool: `context_chain`**
```
context_chain(chain_id: string) → all entries in the chain, chronologically
```

Implementation: `SELECT * FROM entries WHERE tags LIKE '%chain:<id>%' ORDER BY date, time`

**Auto-distill rule update:**
The existing `auto-distill` rule gets enhanced to teach Claude about chains:
```
label: "auto-distill"
content: "When a significant decision is made, a problem is solved, a correction
is given, or something surprising is discovered, save it as an insight to Synaptic
immediately using context_save. Tag corrections with 'correction'. When following up
on a previous decision, include its chain tag. Don't wait for session end."
```

**Pre-commit integration:**
Failure entries from the pre-commit guardian include a chain ID. When the failure resolves, the resolution entry uses the same chain ID. This creates automatic failure → fix threads.

### Files

- Create: `src/tools/context-chain.ts` — Chain query tool
- Modify: `src/server.ts` — Register new tool
- Modify: `src/hooks/session-start.ts` — Update auto-distill rule content

---

## Schema Changes

### No new tables or columns needed.

This version uses only existing schema capabilities:
- Tags for chain IDs (`chain:abc123`)
- Tags for failure metadata (`failure`, `file:X`, `cmd:Y`)
- Existing `file_pairs` table for co-change clusters
- Existing `patterns` table for failure pattern detection

The only schema-adjacent change is the new `bin` field in `package.json`.

---

## New Tools Summary

| Tool | Parameters | Purpose |
|------|-----------|---------|
| `context_dna` | `commits?`, `repo_path?` | Analyze git history, produce codebase DNA report |
| `context_chain` | `chain_id` | Retrieve all entries in a decision chain |

Total tools: 12 existing + 2 new = **14 tools**.

---

## New Files Summary

| File | Purpose |
|------|---------|
| `src/cli.ts` | CLI entry point (`npx synaptic`) |
| `src/cli/init.ts` | Init command — environment detection, config writing |
| `src/cli/pre-commit.ts` | Pre-commit hook — run tests, capture failures |
| `src/storage/watcher.ts` | Git event watcher using fs.watch() |
| `src/tools/context-dna.ts` | Codebase DNA analysis tool |
| `src/tools/context-chain.ts` | Decision chain query tool |

## Modified Files Summary

| File | Changes |
|------|---------|
| `package.json` | Add `bin` field, bump version to 0.6.0 |
| `src/server.ts` | Register 2 new tools, start watcher |
| `src/hooks/session-start.ts` | Enhanced failure pattern formatting, updated auto-distill rule |

---

## Implementation Phases

### Phase 1 — Infrastructure (Features 1-3)

**Tasks:**
1. CLI entry point + command parser
2. Init command — environment detection (WSL/native)
3. Init command — MCP server config writing
4. Init command — Claude Code hooks writing
5. Init command — Git pre-commit hook installation
6. Init command — Project directory creation
7. Watch mode — fs.watch on .git/ events
8. Watch mode — Debounced auto-indexing
9. Watch mode — Integration with MCP server lifecycle
10. Pre-commit guardian — Script detection from package.json
11. Pre-commit guardian — Command execution + error capture
12. Pre-commit guardian — Failure entry creation
13. Pre-commit guardian — Success resolution linking
14. Phase 1 integration test

### Phase 2 — Intelligence (Features 4-6)

**Tasks:**
15. Failure memory — Enhanced pattern formatting in session-start
16. Codebase DNA — Git history analysis (hotspots, layers)
17. Codebase DNA — Commit patterns + co-change clusters
18. Codebase DNA — MCP tool registration
19. Codebase DNA — Auto-run on init
20. Decision chains — context_chain tool
21. Decision chains — Auto-distill rule update
22. Decision chains — Pre-commit failure chain linking
23. Phase 2 integration test
24. Version bump + final smoke tests

---

## Non-Goals

- No web UI or dashboard. Synaptic stays CLI-only.
- No daemon process. Watch mode lives inside the MCP server.
- No CI integration. Pre-commit guardian is local only.
- No AST parsing for DNA. Git history analysis is sufficient.
- No auto-run of `context_dna` on session-start (too expensive).
- No new database tables or columns.
