# Synaptic v0.6.0 — Autonomous Intelligence Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add an installer CLI, real-time git watching, pre-commit failure tracking, codebase DNA analysis, and decision chains to Synaptic.

**Architecture:** Six features split into two phases. Phase 1 builds infrastructure (CLI, watcher, pre-commit hook). Phase 2 builds intelligence (failure memory, DNA analysis, decision chains). No new DB tables or columns — everything uses existing schema with tags.

**Tech Stack:** Node.js 22+ (built-in SQLite), TypeScript, ESM modules, fs.watch(), child_process, zod, MCP SDK.

**Important conventions:**
- All imports use `.js` extensions (ESM): `import { foo } from "./bar.js"`
- The project uses `node:sqlite` (Node.js built-in), NOT `better-sqlite3`
- Smoke tests live in `scripts/smoke-test.ts` — one file, sequential sections
- Build with `npm run build` (runs `tsc`), test with `npm run smoke-test`
- Working directory: `/home/hyperlynq/projects/Coding/claude-context-tool/`

---

## Phase 1 — Infrastructure

### Task 1: CLI Entry Point + Command Parser

**Files:**
- Create: `src/cli.ts`
- Modify: `package.json`

**Step 1: Add the `bin` field to package.json**

Open `package.json` and add the `bin` field after `"main"`:

```json
{
  "name": "synaptic",
  "version": "0.5.0",
  "description": "Persistent local memory for Claude Code — cross-session context recall, BM25 search, zero cloud",
  "type": "module",
  "main": "build/index.js",
  "bin": {
    "synaptic": "build/src/cli.js"
  },
  "scripts": {
```

**Step 2: Create `src/cli.ts`**

This is the entry point for `npx synaptic <command>`. It parses argv and dispatches to subcommands.

```typescript
#!/usr/bin/env node

/**
 * Synaptic CLI — `npx synaptic <command>`
 *
 * Commands:
 *   init      Set up Synaptic for the current project (MCP + hooks + git hook)
 *   init --global  Set up MCP + hooks only (no project-specific setup)
 */

import { initCommand } from "./cli/init.js";

const args = process.argv.slice(2);
const command = args[0];

async function main(): Promise<void> {
  switch (command) {
    case "init":
      await initCommand(args.slice(1));
      break;
    case "--help":
    case "-h":
    case undefined:
      console.log(`
Synaptic — Persistent local memory for Claude Code

Usage: npx synaptic <command>

Commands:
  init           Set up Synaptic for the current project
  init --global  Set up MCP server + hooks only (no git hook)

Options:
  --help, -h     Show this help message
`);
      break;
    default:
      console.error(`Unknown command: ${command}`);
      console.error(`Run "npx synaptic --help" for usage.`);
      process.exit(1);
  }
}

main().catch((err) => {
  console.error(`Error: ${err.message ?? err}`);
  process.exit(1);
});
```

**Step 3: Build and verify the CLI entry point exists**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build`
Expected: Compiles without errors, `build/src/cli.js` exists.

Run: `node build/src/cli.js --help`
Expected: Shows help text (will fail until Task 2 creates `cli/init.ts`, so for now just verify it compiles).

**Step 4: Commit**

```bash
git add src/cli.ts package.json
git commit -m "feat: add CLI entry point with command parser"
```

---

### Task 2: Environment Detection Module

**Files:**
- Create: `src/cli/init.ts`

**Step 1: Create the init command with environment detection**

This module detects WSL vs native, finds the correct settings paths, and will be expanded in later tasks.

```typescript
/**
 * `npx synaptic init` — Set up Synaptic for the current project.
 *
 * Detects environment (WSL or native), finds correct config paths,
 * and sets up MCP server, hooks, git hook, and project directory.
 */

import { existsSync, readFileSync, writeFileSync, mkdirSync, chmodSync } from "node:fs";
import { join, resolve } from "node:path";
import { homedir } from "node:os";
import { execSync } from "node:child_process";

interface Environment {
  isWSL: boolean;
  /** Path to Claude settings.json (Windows-side on WSL, native on Linux/Mac) */
  settingsPath: string;
  /** Path to the synaptic build directory (always Linux-side) */
  buildDir: string;
  /** The node command to use in configs (wsl.exe wrapper on Windows-side, node on native) */
  nodeCommand: string;
  /** Args prefix for the node command */
  nodeArgs: string[];
}

export function detectEnvironment(): Environment {
  const buildDir = resolve(join(import.meta.dirname, ".."));
  const isWSL = existsSync("/proc/version") &&
    readFileSync("/proc/version", "utf-8").toLowerCase().includes("microsoft");

  if (isWSL) {
    // Get Windows user profile path
    let winProfile: string;
    try {
      winProfile = execSync("cmd.exe /C echo %USERPROFILE%", {
        encoding: "utf-8",
        timeout: 5000,
      }).trim().replace(/\r/g, "");
    } catch {
      // Fallback
      winProfile = "C:\\Users\\" + (process.env.USER ?? "user");
    }

    // Convert Windows path to WSL path for file operations
    const winProfileWSL = winProfile.replace(/\\/g, "/").replace(/^([A-Z]):/i, (_, d) => `/mnt/${d.toLowerCase()}`);

    return {
      isWSL: true,
      settingsPath: join(winProfileWSL, ".claude", "settings.json"),
      buildDir,
      nodeCommand: "C:\\WINDOWS\\system32\\wsl.exe",
      nodeArgs: ["node", "--no-warnings"],
    };
  }

  return {
    isWSL: false,
    settingsPath: join(homedir(), ".claude", "settings.json"),
    buildDir,
    nodeCommand: "node",
    nodeArgs: ["--no-warnings"],
  };
}

export async function initCommand(args: string[]): Promise<void> {
  const isGlobal = args.includes("--global");
  const env = detectEnvironment();

  console.log(`Synaptic Init`);
  console.log(`Environment: ${env.isWSL ? "WSL" : "Native"}`);
  console.log(`Settings: ${env.settingsPath}`);
  console.log(`Build dir: ${env.buildDir}\n`);

  // Step 1: MCP server config
  setupMcpServer(env);

  // Step 2: Claude Code hooks
  setupHooks(env);

  if (!isGlobal) {
    // Step 3: Git pre-commit hook
    setupGitHook(env);

    // Step 4: Project directory
    setupProjectDir();
  }

  console.log("\nSynaptic setup complete.");
}

function readJsonFile(path: string): Record<string, unknown> {
  if (!existsSync(path)) return {};
  try {
    return JSON.parse(readFileSync(path, "utf-8"));
  } catch {
    return {};
  }
}

function writeJsonFile(path: string, data: Record<string, unknown>): void {
  const dir = join(path, "..");
  mkdirSync(dir, { recursive: true });
  writeFileSync(path, JSON.stringify(data, null, 2) + "\n", "utf-8");
}

function setupMcpServer(env: Environment): void {
  const settings = readJsonFile(env.settingsPath);
  const mcpServers = (settings.mcpServers ?? {}) as Record<string, unknown>;

  if (mcpServers.synaptic) {
    console.log("[MCP] Already configured — skipping.");
    return;
  }

  const indexPath = join(env.buildDir, "src", "index.js");

  if (env.isWSL) {
    mcpServers.synaptic = {
      command: env.nodeCommand,
      args: [...env.nodeArgs, indexPath],
      type: "stdio",
    };
  } else {
    mcpServers.synaptic = {
      command: env.nodeCommand,
      args: [...env.nodeArgs, indexPath],
      type: "stdio",
    };
  }

  settings.mcpServers = mcpServers;
  writeJsonFile(env.settingsPath, settings);
  console.log("[MCP] Server configured.");
}

function setupHooks(env: Environment): void {
  const settings = readJsonFile(env.settingsPath);
  const hooks = (settings.hooks ?? {}) as Record<string, unknown>;

  const hookScripts = {
    SessionStart: "session-start.js",
    PreCompact: "pre-compact.js",
    Stop: "stop.js",
  };

  let changed = false;

  for (const [hookName, script] of Object.entries(hookScripts)) {
    const existing = hooks[hookName] as unknown[] | undefined;
    const scriptPath = join(env.buildDir, "src", "hooks", script);

    const command = env.isWSL
      ? `wsl node --no-warnings ${scriptPath}`
      : `node --no-warnings ${scriptPath}`;

    // Check if already configured
    const alreadySet = existing?.some((entry: unknown) => {
      const e = entry as Record<string, unknown>;
      const h = (e.hooks as unknown[])?.some((h: unknown) => {
        return (h as Record<string, unknown>).command === command;
      });
      return h;
    });

    if (alreadySet) {
      console.log(`[Hook] ${hookName} — already configured.`);
      continue;
    }

    const hookEntry: Record<string, unknown> = {
      hooks: [{
        type: "command",
        command,
        timeout: hookName === "PreCompact" ? 30000 : 10000,
      }],
    };

    if (hookName === "SessionStart") {
      (hookEntry as Record<string, unknown>).matcher = "startup|resume|compact";
    }

    hooks[hookName] = [...(existing ?? []), hookEntry];
    changed = true;
    console.log(`[Hook] ${hookName} — configured.`);
  }

  if (changed) {
    settings.hooks = hooks;
    writeJsonFile(env.settingsPath, settings);
  }
}

function setupGitHook(env: Environment): void {
  const gitDir = join(process.cwd(), ".git");
  if (!existsSync(gitDir)) {
    console.log("[Git] No .git directory — skipping pre-commit hook.");
    return;
  }

  const hooksDir = join(gitDir, "hooks");
  mkdirSync(hooksDir, { recursive: true });

  const hookPath = join(hooksDir, "pre-commit");
  if (existsSync(hookPath)) {
    const content = readFileSync(hookPath, "utf-8");
    if (content.includes("synaptic")) {
      console.log("[Git] Pre-commit hook already installed — skipping.");
      return;
    }
    // There's an existing hook — don't overwrite
    console.log("[Git] Existing pre-commit hook found — not overwriting.");
    console.log("      To add Synaptic manually, add this to your hook:");
    console.log(`      node --no-warnings ${join(env.buildDir, "src", "cli", "pre-commit.js")}`);
    return;
  }

  const preCommitPath = join(env.buildDir, "src", "cli", "pre-commit.js");
  const hookContent = `#!/bin/sh
# Synaptic pre-commit guardian
node --no-warnings "${preCommitPath}" "$@"
`;

  writeFileSync(hookPath, hookContent, "utf-8");
  chmodSync(hookPath, 0o755);
  console.log("[Git] Pre-commit hook installed.");
}

function setupProjectDir(): void {
  const synapticDir = join(process.cwd(), ".synaptic");

  if (existsSync(synapticDir)) {
    console.log("[Project] .synaptic/ directory already exists — skipping.");
    return;
  }

  mkdirSync(synapticDir, { recursive: true });

  const config = {
    version: "0.6.0",
    created: new Date().toISOString().slice(0, 10),
  };

  writeFileSync(join(synapticDir, "config.json"), JSON.stringify(config, null, 2) + "\n", "utf-8");
  console.log("[Project] Created .synaptic/ directory.");
}
```

**Step 2: Build and test**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build`
Expected: Compiles without errors.

Run: `node build/src/cli.js --help`
Expected: Shows help text with `init` command listed.

**Step 3: Commit**

```bash
git add src/cli.ts src/cli/init.ts
git commit -m "feat: add init command with environment detection, MCP config, hooks, git hook, and project dir setup"
```

---

### Task 3: Init Command Smoke Tests

**Files:**
- Modify: `scripts/smoke-test.ts`

**Step 1: Add smoke tests for the init module**

Add at the end of `scripts/smoke-test.ts`, just before the `// Summary` section (before `index.close()`):

```typescript
  // -------------------------------------------------------
  // 22. Environment detection
  // -------------------------------------------------------
  console.log("\n[22] Environment detection");

  // Import and test detectEnvironment
  const { detectEnvironment } = await import("../src/cli/init.js");
  const env = detectEnvironment();

  // We're running in WSL — verify detection
  assert(typeof env.isWSL === "boolean", "detectEnvironment returns isWSL boolean");
  assert(typeof env.settingsPath === "string" && env.settingsPath.length > 0, "detectEnvironment returns settingsPath");
  assert(typeof env.buildDir === "string" && env.buildDir.length > 0, "detectEnvironment returns buildDir");
  assert(typeof env.nodeCommand === "string", "detectEnvironment returns nodeCommand");
  assert(Array.isArray(env.nodeArgs), "detectEnvironment returns nodeArgs array");
```

**Step 2: Run smoke tests**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run smoke-test`
Expected: All tests pass (96 previous + 5 new = 101).

**Step 3: Commit**

```bash
git add scripts/smoke-test.ts
git commit -m "test: add smoke tests for CLI environment detection"
```

---

### Task 4: Git Event Watcher

**Files:**
- Create: `src/storage/watcher.ts`

**Step 1: Create the watcher module**

```typescript
/**
 * Git event watcher — observes .git/ for branch switches, commits, and rebases.
 * Runs inside the MCP server process. Uses fs.watch() with 2-second debounce.
 */

import { watch, existsSync, readFileSync } from "node:fs";
import { join } from "node:path";
import type { FSWatcher } from "node:fs";
import type { ContextIndex } from "./sqlite.js";
import type { Embedder } from "./embedder.js";
import { isGitRepo } from "./git.js";
import { contextGitIndex } from "../tools/context-git-index.js";
import { appendEntry } from "./markdown.js";
import { detectProject } from "./project.js";
import { getSessionId } from "./session.js";

export interface WatcherOptions {
  cwd?: string;
  index: ContextIndex;
  embedder: Embedder;
  getCurrentProject: () => string | null;
}

export class GitWatcher {
  private watchers: FSWatcher[] = [];
  private debounceTimer: ReturnType<typeof setTimeout> | null = null;
  private lastHead: string | null = null;
  private readonly cwd: string;
  private readonly index: ContextIndex;
  private readonly embedder: Embedder;
  private readonly getCurrentProject: () => string | null;

  constructor(opts: WatcherOptions) {
    this.cwd = opts.cwd ?? process.cwd();
    this.index = opts.index;
    this.embedder = opts.embedder;
    this.getCurrentProject = opts.getCurrentProject;
  }

  start(): void {
    if (!isGitRepo(this.cwd)) return;

    const gitDir = join(this.cwd, ".git");

    // Read initial HEAD for branch switch detection
    try {
      this.lastHead = readFileSync(join(gitDir, "HEAD"), "utf-8").trim();
    } catch {
      // Ignore
    }

    // Watch .git/HEAD — branch switches
    this.watchFile(join(gitDir, "HEAD"));

    // Watch .git/refs/heads/ — new commits
    const refsDir = join(gitDir, "refs", "heads");
    if (existsSync(refsDir)) {
      this.watchDir(refsDir);
    }

    // Watch .git/COMMIT_EDITMSG — commit creation
    // This file doesn't always exist, so we watch the git dir for it
    this.watchFile(join(gitDir, "COMMIT_EDITMSG"));
  }

  stop(): void {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
      this.debounceTimer = null;
    }
    for (const w of this.watchers) {
      try { w.close(); } catch { /* ignore */ }
    }
    this.watchers = [];
  }

  private watchFile(filePath: string): void {
    if (!existsSync(filePath)) return;
    try {
      const w = watch(filePath, () => this.onEvent(filePath));
      this.watchers.push(w);
    } catch {
      // Ignore — file may not be watchable
    }
  }

  private watchDir(dirPath: string): void {
    if (!existsSync(dirPath)) return;
    try {
      const w = watch(dirPath, { recursive: false }, () => this.onEvent(dirPath));
      this.watchers.push(w);
    } catch {
      // Ignore
    }
  }

  private onEvent(source: string): void {
    // Debounce: batch rapid events (e.g., rebase)
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }
    this.debounceTimer = setTimeout(() => {
      this.handleEvent(source).catch(() => {});
    }, 2000);
  }

  private async handleEvent(source: string): Promise<void> {
    // Check for branch switch
    const headPath = join(this.cwd, ".git", "HEAD");
    try {
      const currentHead = readFileSync(headPath, "utf-8").trim();
      if (this.lastHead && currentHead !== this.lastHead) {
        // Branch switch detected
        const branchMatch = currentHead.match(/ref: refs\/heads\/(.+)/);
        if (branchMatch) {
          const branch = branchMatch[1];
          const entry = appendEntry(
            `Switched to branch ${branch}`,
            "progress",
            ["branch-switch", `branch:${branch}`]
          );
          entry.tier = "ephemeral";
          const rowid = this.index.insert({
            ...entry,
            project: this.getCurrentProject() ?? undefined,
            sessionId: getSessionId(),
            agentId: "watcher",
          });
          const embedding = await this.embedder.embed(entry.content);
          this.index.insertVec(rowid, embedding);
        }
      }
      this.lastHead = currentHead;
    } catch {
      // Ignore HEAD read failures
    }

    // Auto-index recent commits
    try {
      await contextGitIndex(
        { repo_path: this.cwd, days: 1 },
        this.index,
        this.embedder
      );
    } catch {
      // Don't crash the server
    }
  }
}
```

**Step 2: Build and verify**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build`
Expected: Compiles without errors.

**Step 3: Commit**

```bash
git add src/storage/watcher.ts
git commit -m "feat: add git event watcher with fs.watch and 2s debounce"
```

---

### Task 5: Integrate Watcher into MCP Server

**Files:**
- Modify: `src/server.ts`

**Step 1: Import and start the watcher**

In `src/server.ts`, add the import at the top (after the existing imports):

```typescript
import { GitWatcher } from "./storage/watcher.js";
```

In the `createServer()` function, after the line `const embedder = _embedder;` (line 38), add:

```typescript
  // Start git event watcher (silent no-op if not a git repo)
  const watcher = new GitWatcher({
    index,
    embedder,
    getCurrentProject: () => _currentProject,
  });
  watcher.start();
```

Also update the version string from `"0.5.0"` to `"0.6.0-alpha.1"` in the McpServer constructor.

**Step 2: Build and verify**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build`
Expected: Compiles without errors.

**Step 3: Commit**

```bash
git add src/server.ts
git commit -m "feat: integrate git watcher into MCP server lifecycle"
```

---

### Task 6: Watcher Smoke Tests

**Files:**
- Modify: `scripts/smoke-test.ts`

**Step 1: Add watcher tests**

Add after the environment detection tests in `scripts/smoke-test.ts`:

```typescript
  // -------------------------------------------------------
  // 23. Git watcher construction
  // -------------------------------------------------------
  console.log("\n[23] Git watcher");

  const { GitWatcher } = await import("../src/storage/watcher.js");

  // Test that watcher can be constructed without error
  const watcher = new GitWatcher({
    cwd: PROJECT_DIR,
    index,
    embedder,
    getCurrentProject: () => "test-project",
  });
  assert(watcher !== null, "GitWatcher constructed successfully");

  // Test that start() doesn't throw (PROJECT_DIR is a git repo)
  watcher.start();
  assert(true, "GitWatcher.start() did not throw");

  // Test that stop() cleans up
  watcher.stop();
  assert(true, "GitWatcher.stop() did not throw");

  // Test with non-git directory
  const watcherNoGit = new GitWatcher({
    cwd: "/tmp",
    index,
    embedder,
    getCurrentProject: () => null,
  });
  watcherNoGit.start(); // Should be no-op
  watcherNoGit.stop();
  assert(true, "GitWatcher with non-git dir is no-op");
```

**Step 2: Run smoke tests**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run smoke-test`
Expected: All tests pass (101 previous + 4 new = 105).

**Step 3: Commit**

```bash
git add scripts/smoke-test.ts
git commit -m "test: add smoke tests for git watcher"
```

---

### Task 7: Pre-Commit Guardian — Script Detection + Execution

**Files:**
- Create: `src/cli/pre-commit.ts`

**Step 1: Create the pre-commit hook script**

```typescript
#!/usr/bin/env node

/**
 * Synaptic pre-commit guardian.
 *
 * Called by .git/hooks/pre-commit. Detects and runs project test/lint commands.
 * On failure: captures error into Synaptic as an issue entry, exits 1.
 * On success: checks for recent failures to link resolutions, exits 0.
 */

import { existsSync, readFileSync } from "node:fs";
import { join } from "node:path";
import { execSync } from "node:child_process";
import { randomBytes } from "node:crypto";
import { ContextIndex } from "../storage/sqlite.js";
import { Embedder } from "../storage/embedder.js";
import { appendEntry } from "../storage/markdown.js";
import { ensureDirs } from "../storage/paths.js";
import { detectProject } from "../storage/project.js";
import { getSessionId } from "../storage/session.js";

interface CheckResult {
  command: string;
  label: string;
  success: boolean;
  output: string;
}

/** Detect which npm scripts to run from package.json */
function detectScripts(cwd: string): Array<{ script: string; label: string }> {
  const pkgPath = join(cwd, "package.json");
  if (!existsSync(pkgPath)) return [];

  let scripts: Record<string, string>;
  try {
    const pkg = JSON.parse(readFileSync(pkgPath, "utf-8"));
    scripts = pkg.scripts ?? {};
  } catch {
    return [];
  }

  const checks: Array<{ script: string; label: string }> = [];

  // Lint
  if (scripts.lint) checks.push({ script: "lint", label: "lint" });
  else if (scripts.eslint) checks.push({ script: "eslint", label: "lint" });

  // Typecheck
  if (scripts.typecheck) checks.push({ script: "typecheck", label: "typecheck" });
  else if (scripts.tsc) checks.push({ script: "tsc", label: "typecheck" });
  else if (scripts.check) checks.push({ script: "check", label: "typecheck" });

  // Test
  if (scripts.test) checks.push({ script: "test", label: "test" });

  return checks;
}

/** Get files being committed (staged files) */
function getStagedFiles(): string[] {
  try {
    const output = execSync("git diff --cached --name-only", {
      encoding: "utf-8",
      timeout: 5000,
    }).trim();
    return output ? output.split("\n") : [];
  } catch {
    return [];
  }
}

/** Run a single check script */
function runCheck(script: string, label: string, cwd: string): CheckResult {
  try {
    const output = execSync(`npm run ${script} 2>&1`, {
      cwd,
      encoding: "utf-8",
      timeout: 120000, // 2 minute timeout
      maxBuffer: 5 * 1024 * 1024,
    });
    return { command: `npm run ${script}`, label, success: true, output: output.slice(-2000) };
  } catch (err) {
    const error = err as { stdout?: string; stderr?: string; status?: number };
    const output = (error.stdout ?? "") + (error.stderr ?? "");
    // Last 50 lines
    const lines = output.split("\n");
    const tail = lines.slice(-50).join("\n");
    return { command: `npm run ${script}`, label, success: false, output: tail };
  }
}

function enrichAndInsert(
  index: ContextIndex,
  entry: import("../storage/markdown.js").ContextEntry
): number {
  return index.insert({
    ...entry,
    project: detectProject() ?? undefined,
    sessionId: getSessionId(),
    agentId: "pre-commit",
  });
}

async function main(): Promise<void> {
  const cwd = process.cwd();
  const scripts = detectScripts(cwd);

  if (scripts.length === 0) {
    // No scripts to check — let commit through
    process.exit(0);
  }

  const stagedFiles = getStagedFiles();
  const fileTags = stagedFiles.slice(0, 10).map(f => `file:${f}`);

  let failed = false;

  for (const { script, label } of scripts) {
    const result = runCheck(script, label, cwd);

    if (!result.success) {
      failed = true;

      // Save failure to Synaptic
      ensureDirs();
      const index = new ContextIndex();
      const embedder = new Embedder();

      try {
        const chainId = randomBytes(4).toString("hex");
        const content = [
          `Pre-commit failure: \`${result.command}\` exited with error`,
          `Files: ${stagedFiles.slice(0, 5).join(", ") || "unknown"}`,
          `Error: ${result.output.slice(-500)}`,
        ].join("\n");

        const entry = appendEntry(content, "issue", [
          "failure",
          "pre-commit",
          `cmd:${label}`,
          `chain:${chainId}`,
          ...fileTags,
        ]);
        entry.tier = "working";

        const rowid = enrichAndInsert(index, entry);
        const embedding = await embedder.embed(content);
        index.insertVec(rowid, embedding);

        console.error(`\n[Synaptic] Failure captured (chain:${chainId})`);
      } finally {
        index.close();
      }

      // Stop on first failure
      process.exit(1);
    }
  }

  // All checks passed — look for recent failures to create resolution entries
  if (!failed && stagedFiles.length > 0) {
    try {
      ensureDirs();
      const index = new ContextIndex();
      const embedder = new Embedder();

      try {
        // Find recent failure entries for these files
        const recentEntries = index.list({ days: 7 });
        const recentFailures = recentEntries.filter(e =>
          e.tags.includes("failure") &&
          e.tags.includes("pre-commit") &&
          stagedFiles.some(f => e.tags.includes(`file:${f}`))
        );

        if (recentFailures.length > 0) {
          // Find the chain ID from the most recent failure
          const lastFailure = recentFailures[0];
          const chainTag = lastFailure.tags.find(t => t.startsWith("chain:"));

          const resolvedFiles = stagedFiles.filter(f =>
            recentFailures.some(e => e.tags.includes(`file:${f}`))
          ).slice(0, 5);

          const content = `Resolved: ${resolvedFiles.join(", ")} now pass pre-commit checks`;
          const tags = [
            "failure-resolved",
            "pre-commit",
            ...(chainTag ? [chainTag] : []),
            ...resolvedFiles.map(f => `file:${f}`),
          ];

          const entry = appendEntry(content, "progress", tags);
          entry.tier = "ephemeral";
          const rowid = enrichAndInsert(index, entry);
          const embedding = await embedder.embed(content);
          index.insertVec(rowid, embedding);
        }
      } finally {
        index.close();
      }
    } catch {
      // Don't block the commit for resolution tracking failures
    }
  }

  process.exit(0);
}

main().catch((err) => {
  console.error(`[Synaptic] Pre-commit error: ${err.message ?? err}`);
  // Don't block commits on Synaptic errors
  process.exit(0);
});
```

**Step 2: Build and verify**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build`
Expected: Compiles without errors. `build/src/cli/pre-commit.js` exists.

**Step 3: Commit**

```bash
git add src/cli/pre-commit.ts
git commit -m "feat: add pre-commit guardian with script detection, failure capture, and resolution linking"
```

---

### Task 8: Pre-Commit Smoke Tests

**Files:**
- Modify: `scripts/smoke-test.ts`

**Step 1: Add pre-commit smoke tests**

Add after the watcher tests:

```typescript
  // -------------------------------------------------------
  // 24. Pre-commit script detection
  // -------------------------------------------------------
  console.log("\n[24] Pre-commit script detection");

  // We can't import pre-commit.ts directly (it calls process.exit),
  // but we can test the script detection logic by reading package.json
  const { readFileSync: readFs } = await import("node:fs");
  const pkgRaw = readFs(join(PROJECT_DIR, "package.json"), "utf-8");
  const pkg = JSON.parse(pkgRaw);
  const scripts = pkg.scripts ?? {};

  // Verify our project has the expected scripts
  assert("build" in scripts, "package.json has build script");
  assert("smoke-test" in scripts, "package.json has smoke-test script");

  // Test failure entry structure
  index.clearAll();
  const failureEntry = makeEntry({
    type: "issue",
    content: "Pre-commit failure: `npm run test` exited with error\nFiles: src/auth.ts\nError: Expected 3 to equal 4",
    tags: ["failure", "pre-commit", "cmd:test", "chain:abcd1234", "file:src/auth.ts"],
  });
  failureEntry.tier = "working";
  const failRowid = index.insert(failureEntry);
  assert(failRowid > 0, "Failure entry inserted successfully");

  // Verify failure entry can be found by tags
  const failures = index.list({ days: 1 }).filter(e =>
    e.tags.includes("failure") && e.tags.includes("pre-commit")
  );
  assert(failures.length === 1, `Found 1 pre-commit failure entry (got ${failures.length})`);
  assert(failures[0].tags.includes("chain:abcd1234"), "Failure has chain tag");
  assert(failures[0].tags.includes("file:src/auth.ts"), "Failure has file tag");

  // Test resolution entry
  const resolveEntry = makeEntry({
    type: "progress",
    content: "Resolved: src/auth.ts now passes pre-commit checks",
    tags: ["failure-resolved", "pre-commit", "chain:abcd1234", "file:src/auth.ts"],
  });
  resolveEntry.tier = "ephemeral";
  index.insert(resolveEntry);

  const chain = index.list({ days: 1 }).filter(e => e.tags.includes("chain:abcd1234"));
  assert(chain.length === 2, `Chain has 2 entries (failure + resolution, got ${chain.length})`);
```

**Step 2: Run smoke tests**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run smoke-test`
Expected: All tests pass (105 previous + 7 new = 112).

**Step 3: Commit**

```bash
git add scripts/smoke-test.ts
git commit -m "test: add smoke tests for pre-commit failure entries and chain linking"
```

---

### Task 9: Phase 1 Integration Verification

**Files:**
- Modify: `src/server.ts` (version bump)

**Step 1: Update version**

In `src/server.ts`, change the version string to `"0.6.0-alpha.2"`.

**Step 2: Full build + smoke test**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run smoke-test`
Expected: All 112 tests pass.

**Step 3: Verify CLI works end-to-end**

Run: `node build/src/cli.js --help`
Expected: Shows help text with init command.

**Step 4: Commit**

```bash
git add src/server.ts
git commit -m "chore: complete Phase 1 — CLI, watcher, pre-commit guardian"
```

---

## Phase 2 — Intelligence

### Task 10: Failure Memory — Enhanced Pattern Formatting

**Files:**
- Modify: `src/hooks/session-start.ts`

**Step 1: Enhance the recurring patterns section to format failure patterns distinctly**

In `src/hooks/session-start.ts`, find the patterns section (around line 153-161) and replace it:

Current code:
```typescript
    const budgetForPatterns: string[] = [];
    const patterns = index.getActivePatterns();
    if (patterns.length > 0) {
      budgetForPatterns.push("## Recurring Issues");
      for (const p of patterns) {
        budgetForPatterns.push(`- "${p.label}" — ${p.occurrenceCount}x (last: ${p.lastSeen.slice(5)})`);
      }
      budgetForPatterns.push("");
    }
```

New code:
```typescript
    const budgetForPatterns: string[] = [];
    const patterns = index.getActivePatterns();
    if (patterns.length > 0) {
      budgetForPatterns.push("## Recurring Issues");
      for (const p of patterns) {
        // Enhanced formatting for pre-commit failure patterns
        const isFailure = p.label.startsWith("Pre-commit failure");
        if (isFailure) {
          // Extract file and command from failure entries
          const fileTags = p.entryIds
            .flatMap(id => {
              const entries = index.list({ days: 30 }).filter(e => e.id === id);
              return entries.flatMap(e => e.tags.filter(t => t.startsWith("file:")));
            })
            .map(t => t.replace("file:", ""));
          const uniqueFiles = [...new Set(fileTags)].slice(0, 3);
          const fileStr = uniqueFiles.length > 0 ? ` (${uniqueFiles.join(", ")})` : "";
          budgetForPatterns.push(`- pre-commit failure${fileStr} — ${p.occurrenceCount}x (last: ${p.lastSeen.slice(5)})`);
        } else {
          budgetForPatterns.push(`- "${p.label}" — ${p.occurrenceCount}x (last: ${p.lastSeen.slice(5)})`);
        }
      }
      budgetForPatterns.push("");
    }
```

**Step 2: Build and verify**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build`
Expected: Compiles without errors.

**Step 3: Commit**

```bash
git add src/hooks/session-start.ts
git commit -m "feat: enhanced failure pattern formatting in session-start injection"
```

---

### Task 11: Codebase DNA — Analysis Logic

**Files:**
- Create: `src/tools/context-dna.ts`

**Step 1: Create the DNA analysis tool**

```typescript
import { z } from "zod";
import { ContextIndex } from "../storage/sqlite.js";
import { Embedder } from "../storage/embedder.js";
import { appendEntry } from "../storage/markdown.js";
import { getGitLog, isGitRepo } from "../storage/git.js";
import { getCurrentProject } from "../server.js";
import { getSessionId } from "../storage/session.js";

export const contextDnaSchema = {
  commits: z
    .number()
    .int()
    .positive()
    .max(500)
    .default(100)
    .describe("Number of recent commits to analyze (default 100)"),
  repo_path: z
    .string()
    .optional()
    .describe("Path to git repository (defaults to cwd)"),
};

interface DnaReport {
  project: string;
  commitsAnalyzed: number;
  hotspots: Array<{ file: string; percentage: number }>;
  layers: Array<{ layer: string; percentage: number }>;
  commitPatterns: {
    prefixes: Array<{ prefix: string; percentage: number }>;
    avgFilesPerCommit: number;
    testRatio: number;
  };
  clusters: Array<string[]>;
}

function analyzeHotspots(
  commits: Array<{ files: Array<{ path: string }> }>
): Array<{ file: string; percentage: number }> {
  const fileCounts = new Map<string, number>();
  for (const commit of commits) {
    for (const file of commit.files) {
      fileCounts.set(file.path, (fileCounts.get(file.path) ?? 0) + 1);
    }
  }

  const threshold = commits.length * 0.2; // >20% of commits
  return Array.from(fileCounts.entries())
    .filter(([, count]) => count >= threshold)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10)
    .map(([file, count]) => ({
      file,
      percentage: Math.round((count / commits.length) * 100),
    }));
}

function analyzeLayers(
  commits: Array<{ files: Array<{ path: string }> }>
): Array<{ layer: string; percentage: number }> {
  const layerCounts = new Map<string, number>();
  let totalFiles = 0;

  for (const commit of commits) {
    for (const file of commit.files) {
      totalFiles++;
      // Extract top-level directory under src/, or use the top-level dir itself
      const parts = file.path.split("/");
      let layer: string;
      if (parts[0] === "src" && parts.length > 1) {
        layer = parts[1] + "/";
      } else {
        layer = parts[0] + (parts[0].includes(".") ? "" : "/");
      }
      layerCounts.set(layer, (layerCounts.get(layer) ?? 0) + 1);
    }
  }

  if (totalFiles === 0) return [];

  return Array.from(layerCounts.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 8)
    .map(([layer, count]) => ({
      layer,
      percentage: Math.round((count / totalFiles) * 100),
    }));
}

function analyzeCommitPatterns(
  commits: Array<{ message: string; files: Array<{ path: string }> }>
): DnaReport["commitPatterns"] {
  const prefixCounts = new Map<string, number>();
  let totalFiles = 0;
  let testFiles = 0;

  for (const commit of commits) {
    // Extract prefix (feat, fix, chore, etc.)
    const prefixMatch = commit.message.match(/^(\w+)[\s(:]/);
    const prefix = prefixMatch ? prefixMatch[1].toLowerCase() : "other";
    prefixCounts.set(prefix, (prefixCounts.get(prefix) ?? 0) + 1);

    totalFiles += commit.files.length;
    testFiles += commit.files.filter(f =>
      f.path.includes("test") || f.path.includes("spec") || f.path.includes("__tests__")
    ).length;
  }

  const prefixes = Array.from(prefixCounts.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([prefix, count]) => ({
      prefix,
      percentage: Math.round((count / commits.length) * 100),
    }));

  return {
    prefixes,
    avgFilesPerCommit: commits.length > 0
      ? Math.round((totalFiles / commits.length) * 10) / 10
      : 0,
    testRatio: totalFiles > 0
      ? Math.round((testFiles / totalFiles) * 10) / 10
      : 0,
  };
}

function analyzeClusters(
  index: ContextIndex,
  project: string
): Array<string[]> {
  // Build adjacency from file_pairs with count >= 3
  const allPairs: Array<{ fileA: string; fileB: string; count: number }> = [];

  // We need to query all file pairs for this project
  // Use getCoChanges for top files as a proxy
  const hotFiles = new Set<string>();

  // Get co-changes for all unique files in recent pairs
  // Simple approach: query pairs via SQL through the index
  // Since we don't have a "list all pairs" method, we'll use a search approach
  // by looking at the top co-changing files from known hotspots
  try {
    // Get files from recent commits
    const commits = getGitLog(process.cwd(), { days: 30 });
    for (const commit of commits) {
      for (const file of commit.files) {
        hotFiles.add(file.path);
      }
    }

    const adjacency = new Map<string, Set<string>>();

    for (const file of Array.from(hotFiles).slice(0, 30)) {
      const cochanges = index.getCoChanges(project, file, 5)
        .filter(c => c.count >= 3);
      if (cochanges.length > 0) {
        if (!adjacency.has(file)) adjacency.set(file, new Set());
        for (const c of cochanges) {
          adjacency.get(file)!.add(c.file);
          if (!adjacency.has(c.file)) adjacency.set(c.file, new Set());
          adjacency.get(c.file)!.add(file);
        }
      }
    }

    // Simple clustering: connected components
    const visited = new Set<string>();
    const clusters: Array<string[]> = [];

    for (const node of adjacency.keys()) {
      if (visited.has(node)) continue;
      const cluster: string[] = [];
      const queue = [node];
      while (queue.length > 0) {
        const current = queue.pop()!;
        if (visited.has(current)) continue;
        visited.add(current);
        cluster.push(current);
        const neighbors = adjacency.get(current);
        if (neighbors) {
          for (const n of neighbors) {
            if (!visited.has(n)) queue.push(n);
          }
        }
      }
      if (cluster.length >= 2) {
        // Use just filenames for readability
        clusters.push(cluster.map(f => f.split("/").pop() ?? f).slice(0, 5));
      }
    }

    return clusters.slice(0, 5);
  } catch {
    return [];
  }
}

function formatReport(report: DnaReport): string {
  const lines: string[] = [];
  lines.push(`Codebase DNA (${report.project}, ${report.commitsAnalyzed} commits analyzed):`);

  if (report.hotspots.length > 0) {
    const hotspotStr = report.hotspots
      .map(h => `${h.file} (${h.percentage}%)`)
      .join(", ");
    lines.push(`Hotspots: ${hotspotStr}`);
  }

  if (report.layers.length > 0) {
    const layerStr = report.layers
      .map(l => `${l.layer} (${l.percentage}%)`)
      .join(", ");
    lines.push(`Layers: ${layerStr}`);
  }

  if (report.commitPatterns.prefixes.length > 0) {
    const prefixStr = report.commitPatterns.prefixes
      .map(p => `${p.percentage}% ${p.prefix}`)
      .join(", ");
    lines.push(
      `Patterns: ${prefixStr}. Avg ${report.commitPatterns.avgFilesPerCommit} files/commit.` +
      (report.commitPatterns.testRatio > 0 ? ` Test ratio: ${report.commitPatterns.testRatio}` : "")
    );
  }

  if (report.clusters.length > 0) {
    const clusterStr = report.clusters
      .map(c => `[${c.join(" + ")}]`)
      .join(", ");
    lines.push(`Clusters: ${clusterStr}`);
  }

  return lines.join("\n");
}

export async function contextDna(
  args: { commits?: number; repo_path?: string },
  index: ContextIndex,
  embedder: Embedder
): Promise<{ success: boolean; report: string; commitsAnalyzed: number }> {
  const repoPath = args.repo_path ?? process.cwd();
  const maxCommits = args.commits ?? 100;

  if (!isGitRepo(repoPath)) {
    return { success: false, report: "Not a git repository", commitsAnalyzed: 0 };
  }

  const project = getCurrentProject() ?? "unknown";

  // Fetch enough days to get ~maxCommits
  // Assume ~5 commits/day, add buffer
  const daysToFetch = Math.ceil(maxCommits / 3) + 30;
  const allCommits = getGitLog(repoPath, { days: daysToFetch });
  const commits = allCommits.slice(0, maxCommits);

  if (commits.length === 0) {
    return { success: false, report: "No commits found", commitsAnalyzed: 0 };
  }

  const report: DnaReport = {
    project,
    commitsAnalyzed: commits.length,
    hotspots: analyzeHotspots(commits),
    layers: analyzeLayers(commits),
    commitPatterns: analyzeCommitPatterns(commits),
    clusters: analyzeClusters(index, project),
  };

  const reportText = formatReport(report);

  // Save as longterm reference entry
  const entry = appendEntry(reportText, "reference", ["codebase-dna", `project:${project}`]);
  entry.tier = "longterm";

  const rowid = index.insert({
    ...entry,
    project: project ?? undefined,
    sessionId: getSessionId(),
    agentId: "dna",
  });
  const embedding = await embedder.embed(reportText);
  index.insertVec(rowid, embedding);

  return {
    success: true,
    report: reportText,
    commitsAnalyzed: commits.length,
  };
}
```

**Step 2: Build and verify**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build`
Expected: Compiles without errors.

**Step 3: Commit**

```bash
git add src/tools/context-dna.ts
git commit -m "feat: add codebase DNA analysis — hotspots, layers, commit patterns, clusters"
```

---

### Task 12: Register context_dna Tool in Server

**Files:**
- Modify: `src/server.ts`

**Step 1: Add import and tool registration**

In `src/server.ts`, add the import at the top with the other tool imports:

```typescript
import { contextDna, contextDnaSchema } from "./tools/context-dna.js";
```

Add the tool registration after the `context_cochanges` registration (before `return server;`):

```typescript
  server.tool(
    "context_dna",
    "Analyze git history to discover codebase patterns, hotspots, architectural layers, and co-change clusters. Saves a longterm reference entry.",
    contextDnaSchema,
    async (args) => {
      const result = await contextDna(args, index, embedder);
      return {
        content: [{ type: "text", text: JSON.stringify(result, null, 2) }],
      };
    }
  );
```

**Step 2: Build and verify**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build`
Expected: Compiles without errors.

**Step 3: Commit**

```bash
git add src/server.ts
git commit -m "feat: register context_dna tool in MCP server"
```

---

### Task 13: DNA Smoke Tests

**Files:**
- Modify: `scripts/smoke-test.ts`

**Step 1: Add DNA analysis tests**

Add after the pre-commit tests:

```typescript
  // -------------------------------------------------------
  // 25. Codebase DNA analysis
  // -------------------------------------------------------
  console.log("\n[25] Codebase DNA");

  index.clearAll();

  const { contextDna } = await import("../src/tools/context-dna.js");

  // Run DNA analysis on the synaptic repo itself
  const dnaResult = await contextDna(
    { commits: 50, repo_path: PROJECT_DIR },
    index,
    embedder
  );

  assert(dnaResult.success === true, "DNA analysis succeeded");
  assert(dnaResult.commitsAnalyzed > 0, `Analyzed ${dnaResult.commitsAnalyzed} commits`);
  assert(dnaResult.report.includes("Codebase DNA"), "Report contains header");
  assert(dnaResult.report.includes("Hotspots:") || dnaResult.report.includes("Layers:"),
    "Report contains analysis sections");

  // Verify it was saved as a reference entry
  const dnaEntries = index.list({ days: 1 }).filter(e =>
    e.type === "reference" && e.tags.includes("codebase-dna")
  );
  assert(dnaEntries.length === 1, `DNA saved as reference entry (got ${dnaEntries.length})`);
  assert(dnaEntries[0].tier === "longterm", "DNA entry has longterm tier");
```

**Step 2: Run smoke tests**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run smoke-test`
Expected: All tests pass (112 previous + 5 new = 117).

**Step 3: Commit**

```bash
git add scripts/smoke-test.ts
git commit -m "test: add smoke tests for codebase DNA analysis"
```

---

### Task 14: Decision Chain Tool

**Files:**
- Create: `src/tools/context-chain.ts`

**Step 1: Create the chain query tool**

```typescript
import { z } from "zod";
import { ContextIndex } from "../storage/sqlite.js";

export const contextChainSchema = {
  chain_id: z
    .string()
    .describe("The chain ID to retrieve (e.g., 'a1b2c3d4' — without the 'chain:' prefix)"),
};

export function contextChain(
  args: { chain_id: string },
  index: ContextIndex
): { chain_id: string; entries: Array<Record<string, unknown>>; total: number } {
  const chainTag = args.chain_id.startsWith("chain:")
    ? args.chain_id
    : `chain:${args.chain_id}`;

  // Search for entries with this chain tag
  const allRecent = index.list({ days: 365 });
  const chainEntries = allRecent
    .filter(e => e.tags.includes(chainTag))
    .sort((a, b) => {
      // Sort chronologically
      const dateCompare = a.date.localeCompare(b.date);
      if (dateCompare !== 0) return dateCompare;
      return a.time.localeCompare(b.time);
    });

  return {
    chain_id: args.chain_id,
    entries: chainEntries.map(e => ({
      id: e.id,
      date: e.date,
      time: e.time,
      type: e.type,
      tags: e.tags,
      content: e.content,
    })),
    total: chainEntries.length,
  };
}
```

**Step 2: Build and verify**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build`
Expected: Compiles without errors.

**Step 3: Commit**

```bash
git add src/tools/context-chain.ts
git commit -m "feat: add context_chain tool for decision chain retrieval"
```

---

### Task 15: Register context_chain Tool in Server

**Files:**
- Modify: `src/server.ts`

**Step 1: Add import and tool registration**

In `src/server.ts`, add the import:

```typescript
import { contextChain, contextChainSchema } from "./tools/context-chain.js";
```

Add the tool registration after `context_dna`:

```typescript
  server.tool(
    "context_chain",
    "Retrieve all entries in a decision chain by chain ID. Returns entries chronologically.",
    contextChainSchema,
    async (args) => {
      const result = contextChain(args, index);
      return {
        content: [{ type: "text", text: JSON.stringify(result, null, 2) }],
      };
    }
  );
```

**Step 2: Build and verify**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build`
Expected: Compiles without errors.

**Step 3: Commit**

```bash
git add src/server.ts
git commit -m "feat: register context_chain tool in MCP server"
```

---

### Task 16: Decision Chain Smoke Tests

**Files:**
- Modify: `scripts/smoke-test.ts`

**Step 1: Add chain tests**

Add after the DNA tests:

```typescript
  // -------------------------------------------------------
  // 26. Decision chains
  // -------------------------------------------------------
  console.log("\n[26] Decision chains");

  index.clearAll();

  const { contextChain } = await import("../src/tools/context-chain.js");

  // Create a chain: decision → progress → issue → decision
  const chainId = "test1234";
  const chainTag = `chain:${chainId}`;

  const decision1 = makeEntry({
    type: "decision",
    content: "Use SQLite instead of LevelDB",
    tags: [chainTag, "database"],
  });
  index.insert(decision1);

  const progress1 = makeEntry({
    type: "progress",
    content: "SQLite migration complete",
    tags: [chainTag],
  });
  index.insert(progress1);

  const issue1 = makeEntry({
    type: "issue",
    content: "SQLite WAL conflicts with WSL",
    tags: [chainTag, "bug"],
  });
  index.insert(issue1);

  const decision2 = makeEntry({
    type: "decision",
    content: "Switch to journal_mode=DELETE",
    tags: [chainTag],
  });
  index.insert(decision2);

  // Query the chain
  const chainResult = contextChain({ chain_id: chainId }, index);
  assert(chainResult.total === 4, `Chain has 4 entries (got ${chainResult.total})`);
  assert(chainResult.chain_id === chainId, "Chain ID matches");
  assert((chainResult.entries[0] as Record<string, unknown>).type === "decision", "First entry is decision");
  assert((chainResult.entries[3] as Record<string, unknown>).type === "decision", "Last entry is decision");

  // Query with chain: prefix should also work
  const chainResult2 = contextChain({ chain_id: `chain:${chainId}` }, index);
  assert(chainResult2.total === 4, "Chain query with prefix also works");

  // Empty chain
  const emptyChain = contextChain({ chain_id: "nonexistent" }, index);
  assert(emptyChain.total === 0, "Non-existent chain returns 0 entries");
```

**Step 2: Run smoke tests**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run smoke-test`
Expected: All tests pass (117 previous + 6 new = 123).

**Step 3: Commit**

```bash
git add scripts/smoke-test.ts
git commit -m "test: add smoke tests for decision chains"
```

---

### Task 17: Update Auto-Distill Rule for Chains

**Files:**
- Modify: `src/hooks/session-start.ts`

**Step 1: Update the auto-distill rule content**

In `src/hooks/session-start.ts`, find the auto-distill rule installation (around lines 50-57) and update the rule content:

Current:
```typescript
    index.saveRule(
      "auto-distill",
      "When a significant decision is made, a problem is solved, a correction is given, or something surprising is discovered, save it as an insight to Synaptic immediately using context_save. Tag corrections with 'correction'. Don't wait for session end."
    );
```

New:
```typescript
    index.saveRule(
      "auto-distill",
      "When a significant decision is made, a problem is solved, a correction is given, or something surprising is discovered, save it as an insight to Synaptic immediately using context_save. Tag corrections with 'correction'. When following up on a previous decision, include its chain tag (e.g., chain:abc123). Don't wait for session end."
    );
```

**Step 2: Build and verify**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build`
Expected: Compiles without errors.

**Step 3: Commit**

```bash
git add src/hooks/session-start.ts
git commit -m "feat: update auto-distill rule to teach chain tag usage"
```

---

### Task 18: Final Smoke Tests + Version Bump

**Files:**
- Modify: `src/server.ts`
- Modify: `package.json`
- Modify: `scripts/smoke-test.ts`

**Step 1: Version bump**

In `package.json`, change version from `"0.5.0"` to `"0.6.0"`.

In `src/server.ts`, change the version in the McpServer constructor to `"0.6.0"`.

**Step 2: Add final integration test section**

Add at the end of `scripts/smoke-test.ts` before the Summary section:

```typescript
  // -------------------------------------------------------
  // 27. v0.6.0 integration check
  // -------------------------------------------------------
  console.log("\n[27] v0.6.0 integration");

  // Verify version
  const pkgFinal = JSON.parse(readFs(join(PROJECT_DIR, "package.json"), "utf-8"));
  assert(pkgFinal.version === "0.6.0", `Version is 0.6.0 (got ${pkgFinal.version})`);

  // Verify bin field exists
  assert(pkgFinal.bin?.synaptic === "build/src/cli.js", "bin field points to CLI");

  // Verify CLI builds
  const { existsSync: existsCheck } = await import("node:fs");
  assert(existsCheck(join(PROJECT_DIR, "build", "src", "cli.js")), "CLI entry point built");
  assert(existsCheck(join(PROJECT_DIR, "build", "src", "cli", "init.js")), "Init command built");
  assert(existsCheck(join(PROJECT_DIR, "build", "src", "cli", "pre-commit.js")), "Pre-commit script built");
  assert(existsCheck(join(PROJECT_DIR, "build", "src", "storage", "watcher.js")), "Watcher module built");
  assert(existsCheck(join(PROJECT_DIR, "build", "src", "tools", "context-dna.js")), "DNA tool built");
  assert(existsCheck(join(PROJECT_DIR, "build", "src", "tools", "context-chain.js")), "Chain tool built");
```

**Step 3: Run final smoke tests**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run smoke-test`
Expected: All tests pass (123 previous + 7 new = 130).

**Step 4: Commit**

```bash
git add src/server.ts package.json scripts/smoke-test.ts
git commit -m "chore: bump version to 0.6.0 — Autonomous Intelligence complete"
```

---

## Summary

**18 tasks** across 2 phases:

| Phase | Tasks | What's Built |
|-------|-------|------|
| Phase 1 (1-9) | CLI + Watcher + Guardian | `npx synaptic init`, real-time git watching, pre-commit failure capture |
| Phase 2 (10-18) | Memory + DNA + Chains | Failure pattern formatting, codebase analysis, decision chain tracking |

**New files (6):**
- `src/cli.ts` — CLI entry point
- `src/cli/init.ts` — Init command
- `src/cli/pre-commit.ts` — Pre-commit guardian
- `src/storage/watcher.ts` — Git event watcher
- `src/tools/context-dna.ts` — Codebase DNA tool
- `src/tools/context-chain.ts` — Decision chain tool

**Modified files (4):**
- `package.json` — bin field, version bump
- `src/server.ts` — 2 new tools, watcher integration, version
- `src/hooks/session-start.ts` — Failure formatting, auto-distill rule update
- `scripts/smoke-test.ts` — 34 new tests (sections 22-27)

**Total tools after v0.6.0: 14** (12 existing + context_dna + context_chain)
**Total tests after v0.6.0: ~130**
