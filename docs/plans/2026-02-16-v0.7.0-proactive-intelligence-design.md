# v0.7.0 — Proactive Intelligence Layer

## Goal

Make Synaptic genuinely intelligent about capturing, predicting, and maintaining context without requiring explicit user instructions. Solve the "wholesale harmony" problem: when a user declares something ("X is my project"), Synaptic should capture it automatically.

## Design Principles

- **Tiered autonomy**: Auto-save facts/declarations/preferences. Require approval for behavioral rules.
- **Predict but don't bloat**: Session-start should anticipate what the user needs, but stay within ~4000 char budget.
- **Loose guard rails**: False positives are cheap (decay handles cleanup). False negatives are the real problem.

---

## Change 1: Intent Classifier (embedder.ts)

### Problem
Stop hook only detects directives ("always", "never") and learnings ("decided", "solution"). Misses declarations ("X is my project"), identity statements, and preferences entirely.

### Solution
Add a third template set — **intent templates**:

```
declaration:  "this is my project"
declaration:  "that's my app"
declaration:  "I built this"
identity:     "my name is"
identity:     "my username is"
preference:   "I like using this tool"
preference:   "I usually do it this way"
frustration:  "this keeps happening"
frustration:  "why does this always break"
ownership:    "this belongs to me"
ownership:    "I own this repository"
```

New method: `getIntentTemplates()` — cached like directive/category templates.

### Classification threshold: **0.6** (lower than directives' 0.75 — false positives are cheap)

### Routing:
- declaration/identity/ownership → `reference` type, `longterm` tier, auto-saved
- preference → `reference` type, `longterm` tier, auto-saved
- frustration → `issue` type, `working` tier, feeds pattern detection

---

## Change 2: Session Planner (session-start.ts)

### Problem
"Related context" section searches by recently changed filenames — no understanding of what the user is about to work on.

### Solution
Replace "Related context" + "Predictive context" sections with a single **"Predicted focus"** section:

1. Gather signals: git branch name, uncommitted file paths, last handoff learnings
2. Concatenate into a semantic search query
3. Run hybrid search (filter out handoffs + git_commits), limit 3
4. Format:
   ```
   ## Predicted focus
   Branch: feature/auth-rework | 3 uncommitted files
   - [2d ago] Decision: switched to JWT from session tokens
   - [5d ago] Issue: CORS headers missing on auth endpoints
   - [1d ago] Insight: refresh token rotation needs Redis
   ```

### Fallback
No git repo or no changes → search against last handoff content only. No handoff → skip section entirely (current behavior).

---

## Change 3: Consolidation Engine (maintenance.ts + sqlite.ts)

### Problem
`findConsolidationCandidates()` exists but is never called. Duplicate entries accumulate.

### Solution
Add `consolidate()` step to `runMaintenance()`:

1. Call `findConsolidationCandidates(0.75)`
2. For each cluster:
   - Keep highest-access-count entry as survivor
   - Append `[Consolidated from N entries]` to survivor content
   - Merge unique tags from all entries into survivor
   - Archive others (recoverable, not deleted)
   - If survivor is ephemeral → promote to working
3. Return consolidation count in MaintenanceReport

### Guard rails
- Only entries **older than 3 days** (don't consolidate active work)
- Never consolidates `rule` or `reference` types
- **No cap** on consolidations per run — trust the 0.75 similarity threshold
- Requires embeddings to exist (skip entries without vectors)

---

## Change 4: Handoff Access Bumps (stop.ts + sqlite.ts)

### Problem
Entries referenced in handoff summaries are clearly important but get no access bump. They can decay despite being significant.

### Solution
Add `touchEntry(id)` method to sqlite.ts:
- Increments `access_count` by 1
- Sets `last_accessed` to current ISO date

In stop hook, after creating handoff:
- Touch all `todayInsights` entries that made it into learnings
- Touch all embedder-classified extras
- Touch all correction-tagged entries that fed into pending rules

### ~5 lines of new code in stop.ts

---

## Change 5: Baked-In Intent Classification (stop.ts)

### Problem
Auto-capture relies on rules (text Claude reads). If Claude doesn't follow the rule, declarations are lost.

### Solution
Add intent classification as a new step in the stop hook, after correction detection:

1. Load intent templates from embedder
2. Scan today's non-insight, non-handoff, non-git_commit entries
3. Classify each against intent templates (0.6 threshold)
4. For matches:
   - Check if a similar entry already exists (cosine similarity > 0.8 against existing references/rules) — deduplicate
   - If new: auto-save with appropriate type/tier per routing rules from Change 1
5. Add count to handoff: `Auto-captured: 2 declarations, 1 preference`

### Safety net, not replacement
Rules (`auto-distill`, `auto-capture-declarations`) stay. They nudge Claude in real-time. The stop hook catches what Claude missed at session end.

---

## Files Changed

| File | Change |
|------|--------|
| `src/storage/embedder.ts` | Add `getIntentTemplates()` method |
| `src/hooks/session-start.ts` | Replace Related+Predictive sections with Predicted Focus |
| `src/storage/maintenance.ts` | Add consolidation step, update MaintenanceReport |
| `src/hooks/stop.ts` | Add intent classification, handoff access bumps |
| `src/storage/sqlite.ts` | Add `touchEntry(id)` method |
| `package.json` | Version bump to 0.7.0 |
| `scripts/smoke-test.ts` | Tests for new features |

No new files. No new tools. No new dependencies. No schema changes.

---

## Version: 0.7.0 — "Proactive Intelligence"
