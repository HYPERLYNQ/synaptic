# Synaptic v0.4.0 — QoL Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Make search fast (pre-warm + cache + BM25 fast path), add enforceable rules (new `rule` type with label-based upsert), and reduce token waste in session-start injection.

**Architecture:** Add LRU cache to Embedder, add `mode` param to search tool, add `label` column + 3 new rule tools, rewrite session-start hook to inject rules first with a token budget.

**Tech Stack:** TypeScript, SQLite (node:sqlite), sqlite-vec, @huggingface/transformers, zod, MCP SDK

---

### Task 1: Schema Migration — Add `label` Column

**Files:**
- Modify: `src/storage/sqlite.ts:97-130` (migrate method)

**Step 1: Write the failing test**

Add to `scripts/smoke-test.ts` at the end (before the summary section at line ~326):

```typescript
// -------------------------------------------------------
// 10. Test rule CRUD
// -------------------------------------------------------
console.log("\n[10] Rule CRUD");

// saveRule creates a new rule
const ruleRowid = index.saveRule("no-emoji", "Never use emoji in commit messages");
assert(typeof ruleRowid === "number" && ruleRowid > 0, `saveRule returned rowid ${ruleRowid}`);

// listRules returns the rule
const rules = index.listRules();
assert(rules.length === 1, `listRules returns 1 rule (got ${rules.length})`);
assert(rules[0].label === "no-emoji", `Rule label is no-emoji`);
assert(rules[0].content.includes("emoji"), `Rule content mentions emoji`);
assert(rules[0].tier === "longterm", `Rule tier is longterm`);
assert(rules[0].pinned === true, `Rule is pinned`);

// saveRule with same label overwrites (upsert)
index.saveRule("no-emoji", "Do not include emoji in any commit messages ever");
const rulesAfterUpdate = index.listRules();
assert(rulesAfterUpdate.length === 1, `Still 1 rule after upsert (got ${rulesAfterUpdate.length})`);
assert(rulesAfterUpdate[0].content.includes("Do not include"), `Rule content was updated`);

// deleteRule removes it
const deleted = index.deleteRule("no-emoji");
assert(deleted === true, `deleteRule returned true`);
const rulesAfterDelete = index.listRules();
assert(rulesAfterDelete.length === 0, `0 rules after delete (got ${rulesAfterDelete.length})`);

// deleteRule on non-existent returns false
const deletedAgain = index.deleteRule("no-emoji");
assert(deletedAgain === false, `deleteRule on missing rule returns false`);
```

**Step 2: Run test to verify it fails**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build && npm run smoke-test`
Expected: FAIL — `index.saveRule is not a function`

**Step 3: Add label column migration + rule methods to ContextIndex**

In `src/storage/sqlite.ts`, add to the end of `migrate()` method (after the `idx_entries_archived` index creation at line ~129):

```typescript
// v0.4.0 migration: add label column for rules
const hasLabel = columns.some((col) => col.name === "label");
if (!hasLabel) {
  this.db.exec("ALTER TABLE entries ADD COLUMN label TEXT");
  this.db.exec(
    "CREATE UNIQUE INDEX IF NOT EXISTS idx_entries_rule_label ON entries(label) WHERE type = 'rule'"
  );
}
```

Add three new methods to the `ContextIndex` class:

```typescript
saveRule(label: string, content: string): number {
  const now = new Date();
  const date = now.toISOString().slice(0, 10);
  const time = now.toTimeString().slice(0, 5);
  const id = Date.now().toString(36) + Math.random().toString(36).slice(2, 6);

  // Upsert: delete existing rule with same label, then insert new
  this.db.prepare("DELETE FROM entries WHERE type = 'rule' AND label = ?").run(label);

  const stmt = this.db.prepare(`
    INSERT INTO entries (id, date, time, type, tags, content, source_file, tier, access_count, last_accessed, pinned, archived, label)
    VALUES (?, ?, ?, 'rule', '', ?, 'rule', 'longterm', 0, NULL, 1, 0, ?)
  `);
  stmt.run(id, date, time, content, label);
  const row = this.db.prepare("SELECT last_insert_rowid() as rowid").get() as Record<string, unknown>;
  return row.rowid as number;
}

listRules(): Array<ContextEntry & { label: string }> {
  const rows = this.db.prepare(
    "SELECT id, date, time, type, tags, content, source_file, tier, access_count, last_accessed, pinned, archived, label FROM entries WHERE type = 'rule' AND archived = 0 ORDER BY date DESC"
  ).all() as Array<Record<string, unknown>>;
  return rows.map((row) => ({
    id: row.id as string,
    date: row.date as string,
    time: row.time as string,
    type: row.type as string,
    tags: (row.tags as string).split(", ").filter(Boolean),
    content: row.content as string,
    sourceFile: row.source_file as string,
    tier: row.tier as ContextEntry["tier"],
    accessCount: row.access_count as number,
    lastAccessed: row.last_accessed as string | null,
    pinned: !!(row.pinned as number),
    archived: !!(row.archived as number),
    label: row.label as string,
  }));
}

deleteRule(label: string): boolean {
  const result = this.db.prepare(
    "DELETE FROM entries WHERE type = 'rule' AND label = ?"
  ).run(label);
  return Number(result.changes) > 0;
}
```

Also update `insert()` to include the label column. Change the INSERT statement at line ~133 to include `label`:

```typescript
insert(entry: ContextEntry & { label?: string }): number {
  const stmt = this.db.prepare(`
    INSERT OR REPLACE INTO entries (id, date, time, type, tags, content, source_file, tier, access_count, last_accessed, pinned, archived, label)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `);
  stmt.run(
    entry.id,
    entry.date,
    entry.time,
    entry.type,
    entry.tags.join(", "),
    entry.content,
    entry.sourceFile,
    entry.tier ?? "working",
    entry.accessCount ?? 0,
    entry.lastAccessed ?? null,
    entry.pinned ? 1 : 0,
    entry.archived ? 1 : 0,
    (entry as any).label ?? null
  );
  const row = this.db.prepare("SELECT last_insert_rowid() as rowid").get() as Record<string, unknown>;
  return row.rowid as number;
}
```

Also update `clearAll()` to handle `label` column — no changes needed since it uses `DELETE FROM entries`.

**Step 4: Run test to verify it passes**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build && npm run smoke-test`
Expected: All tests PASS including new test [10]

**Step 5: Commit**

```bash
git add src/storage/sqlite.ts scripts/smoke-test.ts
git commit -m "feat: add label column and rule CRUD methods to ContextIndex"
```

---

### Task 2: Embedder — Pre-warm + LRU Cache

**Files:**
- Modify: `src/storage/embedder.ts`
- Modify: `src/index.ts`

**Step 1: Write the failing test**

Add to `scripts/smoke-test.ts` before the summary:

```typescript
// -------------------------------------------------------
// 11. Test embedder cache
// -------------------------------------------------------
console.log("\n[11] Embedder cache");

const t0 = performance.now();
const emb1 = await embedder.embed("test cache query");
const t1 = performance.now();
const emb2 = await embedder.embed("test cache query");
const t2 = performance.now();

assert(emb1.length === 384, `Embedding has 384 dims`);
// Cache hit should be significantly faster (< 1ms vs ~100-500ms)
const firstMs = t1 - t0;
const secondMs = t2 - t1;
assert(secondMs < firstMs, `Cached embed is faster (${secondMs.toFixed(1)}ms vs ${firstMs.toFixed(1)}ms)`);
assert(secondMs < 5, `Cached embed is under 5ms (got ${secondMs.toFixed(1)}ms)`);
```

**Step 2: Run test to verify it fails**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build && npm run smoke-test`
Expected: FAIL — cache assertion fails (both calls take similar time)

**Step 3: Add LRU cache to Embedder + pre-warm in index.ts**

Replace `src/storage/embedder.ts` entirely:

```typescript
import {
  pipeline,
  env,
  FeatureExtractionPipeline,
} from "@huggingface/transformers";
import { MODELS_DIR } from "./paths.js";

const MAX_CACHE = 100;

export class Embedder {
  private extractor: FeatureExtractionPipeline | null = null;
  private cache = new Map<string, Float32Array>();

  /** Pre-load the model so first real query is fast. */
  async warmup(): Promise<void> {
    await this.ensureModel();
  }

  private async ensureModel(): Promise<FeatureExtractionPipeline> {
    if (!this.extractor) {
      env.cacheDir = MODELS_DIR;
      // @ts-expect-error -- pipeline() union type too complex for TS; runtime type is correct
      this.extractor = await pipeline(
        "feature-extraction",
        "Xenova/all-MiniLM-L6-v2",
        { dtype: "q8" },
      );
    }
    return this.extractor;
  }

  async embed(text: string): Promise<Float32Array> {
    const key = text.trim().toLowerCase();
    const cached = this.cache.get(key);
    if (cached) return cached;

    const extractor = await this.ensureModel();
    const result = await extractor(text, {
      pooling: "mean",
      normalize: true,
    });
    const embedding = result.data as Float32Array;

    // LRU eviction: delete oldest if at capacity
    if (this.cache.size >= MAX_CACHE) {
      const oldest = this.cache.keys().next().value!;
      this.cache.delete(oldest);
    }
    this.cache.set(key, embedding);

    return embedding;
  }
}
```

Replace `src/index.ts` entirely:

```typescript
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { createServer, getEmbedder } from "./server.js";

const server = createServer();
const transport = new StdioServerTransport();
await server.connect(transport);

// Pre-warm embedder in background (don't block tool registration)
getEmbedder().warmup().catch(() => {});
```

Update `src/server.ts` to export the embedder (add after line 17):

```typescript
let _embedder: Embedder;

export function getEmbedder(): Embedder {
  return _embedder;
}

export function createServer(): McpServer {
  ensureDirs();
  const index = new ContextIndex();
  _embedder = new Embedder();
  const embedder = _embedder;
  // ... rest unchanged
```

**Step 4: Run test to verify it passes**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build && npm run smoke-test`
Expected: All tests PASS — cached embed under 5ms

**Step 5: Commit**

```bash
git add src/storage/embedder.ts src/index.ts src/server.ts scripts/smoke-test.ts
git commit -m "perf: pre-warm embedder on startup + LRU query cache"
```

---

### Task 3: BM25 Fast Path + Batch Access Tracking

**Files:**
- Modify: `src/tools/context-search.ts`
- Modify: `src/storage/sqlite.ts` (bumpAccess method)

**Step 1: Write the failing test**

Add to `scripts/smoke-test.ts` before the summary:

```typescript
// -------------------------------------------------------
// 12. Test BM25 fast path
// -------------------------------------------------------
console.log("\n[12] BM25 fast path");

// search() is BM25-only and should work without embedding
const bm25Results = index.search("PostgreSQL", { limit: 5 });
assert(bm25Results.length > 0, `BM25 search returned ${bm25Results.length} result(s)`);
assert(bm25Results[0].content.includes("PostgreSQL"), `BM25 top result is about PostgreSQL`);
```

**Step 2: Run test to verify it passes (BM25 already works)**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build && npm run smoke-test`
Expected: PASS (BM25 search already exists, this confirms it)

**Step 3: Add `mode` param to context-search tool**

Replace `src/tools/context-search.ts`:

```typescript
import { z } from "zod";
import { ContextIndex } from "../storage/sqlite.js";
import { Embedder } from "../storage/embedder.js";

export const contextSearchSchema = {
  query: z.string().describe("Search query (hybrid semantic + keyword search)"),
  type: z
    .enum(["decision", "progress", "issue", "handoff", "insight", "reference", "git_commit", "rule"])
    .optional()
    .describe("Filter by entry type"),
  days: z
    .number()
    .int()
    .positive()
    .optional()
    .describe("Only search entries from last N days"),
  limit: z
    .number()
    .int()
    .positive()
    .max(100)
    .default(20)
    .describe("Maximum results to return"),
  tier: z
    .enum(["ephemeral", "working", "longterm"])
    .optional()
    .describe("Filter results to specific memory tier"),
  include_archived: z
    .boolean()
    .optional()
    .default(false)
    .describe("Include archived entries in results"),
  mode: z
    .enum(["fast", "semantic", "hybrid"])
    .optional()
    .describe("Search mode: fast (BM25 keyword only), semantic (vector only), hybrid (both). Auto-detects if omitted."),
};

function autoDetectMode(query: string): "fast" | "hybrid" {
  const words = query.trim().split(/\s+/);
  if (words.length <= 3 && !query.includes("?")) return "fast";
  return "hybrid";
}

export async function contextSearch(
  args: { query: string; type?: string; days?: number; limit?: number; tier?: string; include_archived?: boolean; mode?: string },
  index: ContextIndex,
  embedder: Embedder
): Promise<{
  results: Array<{
    id: string;
    date: string;
    time: string;
    type: string;
    tags: string[];
    content: string;
  }>;
  total: number;
}> {
  const mode = (args.mode as "fast" | "semantic" | "hybrid") ?? autoDetectMode(args.query);

  let results: import("../storage/markdown.js").ContextEntry[];

  if (mode === "fast") {
    // BM25 only — no embedding call
    results = index.search(args.query, {
      type: args.type,
      days: args.days,
      limit: args.limit,
      includeArchived: args.include_archived,
    });
    index.bumpAccess(results.map((e) => e.id));
  } else if (mode === "semantic") {
    // Vector only
    const embedding = await embedder.embed(args.query);
    const limit = args.limit ?? 20;
    const vecResults = index.searchVec(embedding, limit * 3);
    const entries = index.getByRowids(vecResults.map((r) => r.rowid));
    results = entries.filter((e) => {
      if (!args.include_archived && e.archived) return false;
      if (args.tier && e.tier !== args.tier) return false;
      if (args.type && e.type !== args.type) return false;
      return true;
    }).slice(0, limit);
    index.bumpAccess(results.map((e) => e.id));
  } else {
    // Hybrid (default)
    const embedding = await embedder.embed(args.query);
    results = index.hybridSearch(args.query, embedding, {
      type: args.type,
      days: args.days,
      limit: args.limit,
      tier: args.tier,
      includeArchived: args.include_archived,
    });
  }

  const enriched = results.map((r) => {
    const pattern = index.getPatternForEntry(r.id);
    return {
      id: r.id,
      date: r.date,
      time: r.time,
      type: r.type,
      tags: r.tags,
      content: r.content,
      ...(r.tier ? { tier: r.tier } : {}),
      ...(pattern ? { pattern: `Recurring pattern: seen ${pattern.occurrenceCount} times (pattern: ${pattern.id})` } : {}),
    };
  });

  return {
    results: enriched,
    total: enriched.length,
  };
}
```

**Step 4: Batch bumpAccess**

In `src/storage/sqlite.ts`, replace the `bumpAccess` method (lines 415-424):

```typescript
bumpAccess(ids: string[]): void {
  if (ids.length === 0) return;
  const now = new Date().toISOString().slice(0, 10);
  const placeholders = ids.map(() => "?").join(", ");
  this.db.prepare(
    `UPDATE entries SET access_count = access_count + 1, last_accessed = ? WHERE id IN (${placeholders})`
  ).run(now, ...ids);
}
```

**Step 5: Run test to verify it passes**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build && npm run smoke-test`
Expected: All tests PASS

**Step 6: Commit**

```bash
git add src/tools/context-search.ts src/storage/sqlite.ts scripts/smoke-test.ts
git commit -m "perf: BM25 fast path with auto-detect + batch access tracking"
```

---

### Task 4: New Rule Tools + Server Registration

**Files:**
- Create: `src/tools/context-save-rule.ts`
- Create: `src/tools/context-delete-rule.ts`
- Create: `src/tools/context-list-rules.ts`
- Modify: `src/server.ts`

**Step 1: Create `src/tools/context-save-rule.ts`**

```typescript
import { z } from "zod";
import { ContextIndex } from "../storage/sqlite.js";

export const contextSaveRuleSchema = {
  label: z.string().describe("Unique short key for the rule (e.g. 'no-emoji', 'commit-style')"),
  content: z.string().describe("The rule text — what Claude must always follow"),
};

export function contextSaveRule(
  args: { label: string; content: string },
  index: ContextIndex
): { success: boolean; label: string; action: string } {
  // Determine if this is an insert or update
  const existing = index.listRules().find((r) => r.label === args.label);
  index.saveRule(args.label, args.content);
  return {
    success: true,
    label: args.label,
    action: existing ? "updated" : "created",
  };
}
```

**Step 2: Create `src/tools/context-delete-rule.ts`**

```typescript
import { z } from "zod";
import { ContextIndex } from "../storage/sqlite.js";

export const contextDeleteRuleSchema = {
  label: z.string().describe("Label of the rule to delete"),
};

export function contextDeleteRule(
  args: { label: string },
  index: ContextIndex
): { success: boolean; label: string } {
  const deleted = index.deleteRule(args.label);
  return {
    success: deleted,
    label: args.label,
  };
}
```

**Step 3: Create `src/tools/context-list-rules.ts`**

```typescript
import { ContextIndex } from "../storage/sqlite.js";

export function contextListRules(
  index: ContextIndex
): { rules: Array<{ label: string; content: string; date: string }> } {
  const rules = index.listRules();
  return {
    rules: rules.map((r) => ({
      label: r.label,
      content: r.content,
      date: r.date,
    })),
  };
}
```

**Step 4: Register in `src/server.ts`**

Add imports at the top:

```typescript
import { contextSaveRule, contextSaveRuleSchema } from "./tools/context-save-rule.js";
import { contextDeleteRule, contextDeleteRuleSchema } from "./tools/context-delete-rule.js";
import { contextListRules } from "./tools/context-list-rules.js";
```

Add tool registrations inside `createServer()` (before `return server`):

```typescript
server.tool(
  "context_save_rule",
  "Save or update a persistent rule by label. Rules are injected every session and always enforced. If a rule with this label exists, it is overwritten.",
  contextSaveRuleSchema,
  async (args) => {
    const result = contextSaveRule(args, index);
    return {
      content: [{ type: "text", text: JSON.stringify(result, null, 2) }],
    };
  }
);

server.tool(
  "context_delete_rule",
  "Delete a persistent rule by its label.",
  contextDeleteRuleSchema,
  async (args) => {
    const result = contextDeleteRule(args, index);
    return {
      content: [{ type: "text", text: JSON.stringify(result, null, 2) }],
    };
  }
);

server.tool(
  "context_list_rules",
  "List all active rules with their labels and content.",
  {},
  async () => {
    const result = contextListRules(index);
    return {
      content: [{ type: "text", text: JSON.stringify(result, null, 2) }],
    };
  }
);
```

Also update the `context_save` type enum to include `"rule"` (in `src/tools/context-save.ts` line 9):

```typescript
.enum(["decision", "progress", "issue", "handoff", "insight", "reference", "git_commit", "rule"])
```

Update version in `server.ts` (line 21):

```typescript
version: "0.4.0",
```

**Step 5: Run test to verify it passes**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build && npm run smoke-test`
Expected: All tests PASS

**Step 6: Commit**

```bash
git add src/tools/context-save-rule.ts src/tools/context-delete-rule.ts src/tools/context-list-rules.ts src/server.ts src/tools/context-save.ts
git commit -m "feat: add rule tools (save, delete, list) with label-based upsert"
```

---

### Task 5: Session-Start — Rules First + Token Budget + Compact Format

**Files:**
- Modify: `src/hooks/session-start.ts`

**Step 1: Rewrite session-start hook**

Replace `src/hooks/session-start.ts` entirely:

```typescript
/**
 * SessionStart hook: Injects rules + recent context into Claude's conversation.
 * Stdout from this hook is automatically added to Claude's context.
 *
 * Injection priority (token budget ~3200 chars):
 * 1. Rules (always full, never truncated)
 * 2. Recent context (last 3 days, compact format)
 * 3. Most recent handoff note (1 only)
 * 4. Recurring patterns
 * 5. Maintenance summary (only if something changed)
 */

import { ContextIndex } from "../storage/sqlite.js";
import { ensureDirs } from "../storage/paths.js";
import { runMaintenance } from "../storage/maintenance.js";
import { Embedder } from "../storage/embedder.js";
import { contextGitIndex } from "../tools/context-git-index.js";

const TOKEN_BUDGET_CHARS = 3200; // ~800 tokens

interface SessionStartInput {
  source: string;
}

async function main(): Promise<void> {
  ensureDirs();

  let input: SessionStartInput = { source: "startup" };
  try {
    const chunks: Buffer[] = [];
    for await (const chunk of process.stdin) {
      chunks.push(chunk as Buffer);
    }
    const raw = Buffer.concat(chunks).toString("utf-8").trim();
    if (raw) {
      input = JSON.parse(raw);
    }
  } catch {
    // Use defaults
  }

  const index = new ContextIndex();

  // Run maintenance
  const maintenance = runMaintenance(index);

  try {
    // Auto-index recent git commits (silent)
    const embedder = new Embedder();
    try {
      await contextGitIndex({ days: 1 }, index, embedder);
    } catch {
      // Don't block session start
    }

    const lines: string[] = [];
    let charCount = 0;

    // --- SECTION 1: Rules (always full, never truncated) ---
    const rules = index.listRules();
    if (rules.length > 0) {
      lines.push("# Rules (ALWAYS follow, NO exceptions)");
      for (const rule of rules) {
        lines.push(`- ${rule.content}`);
      }
      lines.push("");
    }
    charCount = lines.join("\n").length;

    // --- SECTION 2: Recent handoff (1 only) ---
    const budgetForHandoff: string[] = [];
    const handoffs = index.list({ days: 7, type: "handoff" }).slice(0, 1);
    if (handoffs.length > 0) {
      const h = handoffs[0];
      budgetForHandoff.push("## Recent Handoff");
      budgetForHandoff.push(`- ${h.date.slice(5)} ${h.time} [${h.tags.join(", ")}]: ${h.content}`);
      budgetForHandoff.push("");
    }

    // --- SECTION 3: Recent context (last 3 days, compact) ---
    const budgetForContext: string[] = [];
    const recent = index.list({ days: 3 })
      .filter(e => e.tier !== "ephemeral" && e.type !== "handoff" && e.type !== "rule");
    if (recent.length > 0) {
      budgetForContext.push("## Recent Context (last 3 days)");
      let currentDate = "";
      for (const entry of recent.slice(0, 15)) {
        if (entry.date !== currentDate) {
          currentDate = entry.date;
          budgetForContext.push(`\n### ${currentDate.slice(5)}`);
        }
        budgetForContext.push(`- ${entry.time} [${entry.type}] ${entry.content}`);
      }
      budgetForContext.push("");
    }

    // --- SECTION 4: Recurring patterns ---
    const budgetForPatterns: string[] = [];
    const patterns = index.getActivePatterns();
    if (patterns.length > 0) {
      budgetForPatterns.push("## Recurring Issues");
      for (const p of patterns) {
        budgetForPatterns.push(`- "${p.label}" — ${p.occurrenceCount}x (last: ${p.lastSeen.slice(5)})`);
      }
      budgetForPatterns.push("");
    }

    // --- SECTION 5: Maintenance (only if something happened) ---
    const budgetForMaint: string[] = [];
    const maintTotal = maintenance.decayed + maintenance.demoted + maintenance.promotedStable + maintenance.promotedFrequent;
    if (maintTotal > 0) {
      const parts: string[] = [];
      if (maintenance.decayed > 0) parts.push(`${maintenance.decayed} archived`);
      if (maintenance.demoted > 0) parts.push(`${maintenance.demoted} demoted`);
      if (maintenance.promotedStable > 0) parts.push(`${maintenance.promotedStable} promoted`);
      if (maintenance.promotedFrequent > 0) parts.push(`${maintenance.promotedFrequent} promoted`);
      budgetForMaint.push(`_Maintenance: ${parts.join(", ")}._`);
    }

    // --- Assemble within budget ---
    const sections = [budgetForContext, budgetForHandoff, budgetForPatterns, budgetForMaint];
    for (const section of sections) {
      const sectionText = section.join("\n");
      if (charCount + sectionText.length <= TOKEN_BUDGET_CHARS) {
        lines.push(...section);
        charCount += sectionText.length;
      }
    }

    // Always append entry count (tiny)
    const stats = index.status();
    lines.push(`\n_${stats.totalEntries} total entries in context store._`);

    if (lines.length <= 1) return; // Nothing to inject

    process.stdout.write(lines.join("\n"));
  } finally {
    index.close();
  }
}

main().catch((err) => {
  process.stderr.write(`session-start hook error: ${err}\n`);
  process.exit(0);
});
```

**Step 2: Build and verify**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build`
Expected: Clean build, no errors

**Step 3: Commit**

```bash
git add src/hooks/session-start.ts
git commit -m "feat: rules-first session injection with token budget and compact format"
```

---

### Task 6: Update context-list type enum + Bump Version

**Files:**
- Modify: `src/tools/context-list.ts` (add "rule" to type enum)
- Modify: `package.json` (bump to 0.4.0)

**Step 1: Add "rule" to context-list type enum**

In `src/tools/context-list.ts`, find the type enum and add `"rule"`:

```typescript
.enum(["decision", "progress", "issue", "handoff", "insight", "reference", "git_commit", "rule"])
```

**Step 2: Bump version in `package.json`**

Change `"version": "0.3.0"` to `"version": "0.4.0"`.

**Step 3: Build + full smoke test**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build && npm run smoke-test`
Expected: All tests PASS

**Step 4: Commit**

```bash
git add src/tools/context-list.ts package.json
git commit -m "chore: bump version to 0.4.0, add rule type to all enums"
```

---

### Task 7: Final Build + Manual Verification

**Files:** None (verification only)

**Step 1: Full rebuild + smoke test**

Run: `cd /home/hyperlynq/projects/Coding/claude-context-tool && npm run build && npm run smoke-test`
Expected: All tests PASS, clean build

**Step 2: Verify session-start hook runs cleanly**

Run: `echo '{"source":"startup"}' | node /home/hyperlynq/projects/Coding/claude-context-tool/build/hooks/session-start.js`
Expected: Output starts with rules (if any exist), followed by compact context, within token budget

**Step 3: Commit any stragglers**

If clean, no commit needed. If any fixes: commit them.

---

## Summary

| Task | What | Key Files |
|------|------|-----------|
| 1 | Schema migration + rule CRUD | `sqlite.ts`, `smoke-test.ts` |
| 2 | Embedder pre-warm + LRU cache | `embedder.ts`, `index.ts`, `server.ts` |
| 3 | BM25 fast path + batch access | `context-search.ts`, `sqlite.ts` |
| 4 | Rule tools + server registration | 3 new tools, `server.ts` |
| 5 | Session-start rewrite | `session-start.ts` |
| 6 | Type enums + version bump | `context-list.ts`, `package.json` |
| 7 | Final verification | None (test only) |
